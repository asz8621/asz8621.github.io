[{"title":"Vue nextTick 應用場景與實踐","url":"/vue/nexttick/","content":"\n## 前言\n\n當使用 Vue.js 開發應用時，`nextTick` 是一個非常有用的方法，當資料變化時 Vue 會異步更新 DOM，有時候你可能會在資料改變後立即嘗試訪問 DOM，卻發現其實 DOM 還沒有更新。為了解決這個問題，`nextTick` 可以讓你在下次 DOM 更新循環後執行一段代碼，可以幫助你在 DOM 更新後執行某些操作。\n\n## 基本用法\n\n以下是在 Vue 中使用 `nextTick` 的一個方法，用於在 DOM 更新後執行操作\n\n```html\n<template>\n  <div>\n    <input v-if=\"inputState\" ref=\"inputText\" type=\"text\" :value=\"text\">\n    <button type=\"button\" @click=\"inputHandler\">隱藏/顯示</button>\n  </div>\n</template>\n```\n\n{% tabs nextTick %}\n<!-- tab Vue 2 -->\n```javascript\n<script>\nexport default {\n  name: 'App',\n  data() {\n    return {\n      text: 'Hello Vue!',\n      inputState: true,\n    }\n  },\n  created() {\n    // 當元件建立完成時，自動 focus 到 input\n    this.$nextTic(() => {\n      this.$refs.inputText.focus()\n    })\n  },\n  methods: {\n    inputHandler() {\n      this.inputState = !this.inputState\n      if (this.inputState) {\n        this.$nextTic(() => {\n          this.$refs.inputText.focus()\n        })\n      }\n    }\n  }\n}\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 -->\n```javascript\n<script>\nimport { ref, onMounted, nextTick } from 'vue';\n\nexport default {\n  name: 'App',\n  setup() {\n    const text = ref('Hello Vue!');\n    const inputState = ref(true);\n    const inputText = ref(null);\n\n    const inputHandler = () => {\n      inputState.value = !inputState.value;\n      if (inputState.value) {\n        nextTick(() => {\n          inputText.value.focus();\n        });\n      }\n    };\n\n    onMounted(() => {\n      nextTick(() => {\n        inputText.value.focus();\n      });\n    });\n\n    return {\n      text,\n      inputState,\n      inputHandler,\n      inputText,\n    };\n  },\n};\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 語法糖 -->\n```javascript\n<script setup>\nimport { ref, onMounted, nextTick } from 'vue';\n\nconst text = ref('Hello Vue!');\nconst inputState = ref(true);\nconst inputText = ref(null);\n\nconst inputHandler = () => {\n  inputState.value = !inputState.value;\n  if (inputState.value) {\n    nextTick(() => {\n      inputText.value.focus();\n    });\n  }\n};\n\nonMounted(() => {\n  nextTick(() => {\n    inputText.value.focus();\n  });\n});\n</script>\n```\n<!-- endtab -->\n{% endtabs %}\n\n在這個範例中，會等到 input 顯示後才會自動 `focus`，確保用戶可以立即輸入內容。\n\n## 注意事項\n\n- 在 Vue 2 中使用 `nextTick` 前面要加上 `$`\n- `nextTick` 可以接受一個回調函數，這個回調會在 DOM 更新完成後被調用。\n- 你也可以使用 `Promise` 語法來處理 `nextTick`，這在使用 `async/await` 時特別方便：\n\n```javascript\nasync updateMessage() {\n  this.message = 'Hello Async Next Tick!';\n  await this.$nextTic();\n  console.log('DOM updated (async):', this.$el.textContent);\n}\n```\n\n## 總結\n\n`nextTick` 是一個強大的工具，可以幫助你在 Vue 應用中確保在 DOM 更新後執行代碼。合理使用 `nextTick` 可以提高應用的穩定性和性能，特別是在處理複雜的 UI 更新時。希望這些筆記能幫助你更好地理解和運用 `nextTick`！\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue v-for 與 v-if 搭配使用","url":"/vue/use-v-for-with-v-if/","content":"\n## 前言\n\n在 Vue.js 中，`v-for` 和 `v-if` 是兩個常用的指令，它們各自有著重要的功能。當我們將這兩者搭配使用時，可以實現更加動態和靈活的 UI。不過，直接在 v-for 中使用 v-if 會導致錯誤。這篇文章將探討這兩個指令如何搭配使用的場景，並提供解決方法。\n\n## 錯誤範例\n\n```html\n<template>\n  <ul>\n    <li v-for=\"task in tasks\" :key=\"task.id\" v-if=\"!task.completed\">\n      {{ task.name }}\n    </li>\n  </ul>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      tasks: [\n        { id: 1, name: '任務 1', completed: false },\n        { id: 2, name: '任務 2', completed: true },\n        { id: 3, name: '任務 3', completed: false },\n      ],\n    };\n  },\n};\n</script>\n```\n\n此範例會出現以下錯誤：\n\n```vscode\nThe 'XXXXX' variable inside 'v-for' directive should be replaced with a computed property that returns filtered array instead. You should not mix 'v-for' with 'v-if'\n```\n\n這是因為 `v-for` 和 `v-if` 的優先級不同，當它們同時存在於同一節點時，`v-if` 的優先級高於 `v-for`，使得 `v-if` 的條件無法訪問到 `v-for` 作用域內的變量別名。\n\n## 正確範例\n\n```html\n<template>\n  <div>\n    <h1>任務清單</h1>\n    <p>已完成清單</p>\n    <ul>\n      <template v-for=\"task in tasks\">\n        <li v-if=\"task.completed\" :key=\"task.id\">\n          {{ task.name }}\n        </li>\n      </template>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      tasks: [\n        { id: 1, name: '任務 1', completed: false },\n        { id: 2, name: '任務 2', completed: true },\n        { id: 3, name: '任務 3', completed: false },\n      ],\n    };\n  },\n};\n</script>\n```\n\n![Use v-for with v-if](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2FUse%20v-for%20with%20v-if.png?alt=media&token=1c99aa46-19f0-424d-b7ad-024af806f746)\n\n## 結論\n\n`v-for` 和 `v-if` 的搭配使用可以讓我們在 Vue.js 中靈活地構建條件渲染的列表。這不僅提升了應用的互動性和動態性，也增強了可讀性。在實際開發中，請考慮性能與可讀性，選擇最適合的方式來實現需求。\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue 的 watch & watchEffect 差別","url":"/vue/watch-and-watcheffect/","content":"\n## `watch` 與 `watchEffect` 的差異\n\n| 功能 / 特性        | `watch`               | `watchEffect`                     |\n|-------------------|---------------------|-----------------------------------|\n| 參數               | `(newValue, oldValue)` | `()`                               |\n| 查詢舊值          | 可以                 | 不能                               |\n| 觸發條件          | 屬性改變時才執行<br>(可設定 `immediate` 以初始化執行一次) | 初始化執行一次，屬性改變時再執行   |\n| 屬性指定          | 需要指定屬性       | 不需要指定屬性                    |\n| 停止監聽          | 不可停止           | 可以停止                           |\n| 多次觸發執行      | 是                  | 是（可進行節流）                 |\n\n## 使用方式\n\n### 一般用法\n\n```javascript\n<script setup>\nimport { ref, watch, watchEffect } from 'vue'\n\nconst text = ref('安安')\n\nwatchEffect(() => {\n  console.log('watchEffect:', text.value)\n})\n\nwatch(() => text.value, (newValue, oldValue) => {\n  console.log('watch:', newValue, oldValue)\n})\n</script>\n```\n\n![示範圖1](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fwatch%20and%20watcheffect%201.png?alt=media&token=a2086b09-78e6-40de-8410-7ab6705c149d)\n\n### 使用 `immediate` 的 `watch`\n\n```javascript\n<script setup>\nimport { ref, watch, watchEffect } from 'vue'\n\nconst text = ref('安安')\n\nwatchEffect(() => {\n  console.log('watchEffect:', text.value)\n})\n\nwatch(\n  () => text.value,\n  (newValue, oldValue) => {\n    console.log('watch:', newValue, oldValue)\n  },\n  { immediate: true },\n)\n</script>\n```\n\n![示範圖2](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fwatch%20and%20watcheffect%202.png?alt=media&token=63a61f67-3cc4-4cde-9674-7e4bdf6f9625)\n\n### 改變屬性\n\n```javascript\n<script setup>\nimport { ref, watch, watchEffect } from 'vue'\n\nconst text = ref('安安')\n\nwatchEffect(() => {\n  console.log('watchEffect:', text.value)\n})\n\nwatch(\n  () => text.value,\n  (newValue, oldValue) => {\n    console.log('watch:', newValue, oldValue)\n  },\n)\n\nconst changeText = () => {\n  text.value = '你好'\n}\n</script>\n\n<template>\n  <div @click=\"changeText\">\n    改變\n  </div>\n</template>\n```\n\n![示範圖3](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fwatch%20and%20watcheffect%203.gif?alt=media&token=2dab075a-4560-4f37-be20-c788bb206d5a)\n\n### 使用 `watchEffect` 停止監聽\n\n```javascript\n<script setup>\nimport { ref, watch, watchEffect } from 'vue'\n\nconst count = ref(0)\nconst stop = watchEffect(() => {\n  console.log(`watchEffect: ${count.value}`)\n})\n\nconst changeCount = () => {\n  count.value += 1\n  if (count.value > 5) stop()\n}\n\nwatch(\n  () => count.value,\n  (newValue, oldValue) => {\n    console.log(`watch: ${newValue}, ${oldValue}`)\n  },\n)\n</script>\n\n<template>\n  <div class=\"text-right\">\n    <v-btn class=\"mt-10 px-10\" @click=\"changeCount\">\n      改變-count: {{ count }}\n    </v-btn>\n  </div>\n</template>\n```\n\n當 `count` 大於 5 時，會停止監聽。\n\n![示範圖4](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fwatch%20and%20watcheffect%204.gif?alt=media&token=08a294f8-8df0-4b48-8130-0ee8c5ecc852)\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue 中的 v-if、v-else 和 v-else-if 條件渲染","url":"/vue/conditional-rendering/","content":"\n## 前言\n\n當你在使用 Vue.js 開發應用時，控制顯示或隱藏元素是一個常見的需求。Vue.js 提供了 `v-if`、`v-else` 和 `v-else-if` 指令，讓你能夠根據條件動態顯示內容。以下是這些指令的介紹及使用範例。\n\n## `v-if`\n\n`v-if` 指令用來根據條件來顯示或隱藏元素。當條件為 `true` 時，該元素會被渲染；當條件為 `false` 時，該元素不會被渲染。\n\n```html\n<template>\n  <div class=\"text-right\">\n    <button type=\"button\" @click=\"toggle\">切換顯示</button>\n    <p v-if=\"isVisible\">這是一段顯示的文本。</p>\n  </div>\n</template>\n```\n\n{% tabs v-if %}\n<!-- tab Vue 2 -->\n```javascript\n<script>\nexport default {\n  data() {\n    return {\n      isVisible: false\n    };\n  },\n  methods: {\n    toggle() {\n      this.isVisible = !this.isVisible;\n    }\n  }\n};\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 -->\n```javascript\n<script>\nimport { ref } from 'vue';\n\nexport default {\n  setup() {\n    const isVisible = ref(false);\n\n    const toggle = () => {\n      isVisible.value = !isVisible.value;\n    };\n\n    return {\n      isVisible,\n      toggle\n    };\n  }\n};\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 語法糖 -->\n```javascript\n<script setup>\nimport { ref } from 'vue';\n\nconst isVisible = ref(false);\n\nconst toggle = () => {\n  isVisible.value = !isVisible.value;\n};\n</script>\n```\n<!-- endtab -->\n{% endtabs %}\n\n在這個範例中，當按鈕被點擊時，`isVisible` 的值會在 `true` 和 `false` 之間切換，從而控制 `<p>` 標籤的顯示。\n\n![v-if](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fv-if.gif?alt=media&token=b023ede8-c11a-49b9-9cea-93ebba75ccee)\n\n## `v-else`\n\n`v-else` 是用於在 `v-if` 的條件不滿足時顯示的元素。它必須緊接在 `v-if` 或 `v-else-if` 的元素之後。\n\n```html\n<template>\n  <div class=\"text-right\">\n    <button @click=\"toggle\">切換顯示</button>\n    <p v-if=\"isVisible\">目前為 true</p>\n    <p v-else>目前為 false</p>\n  </div>\n</template>\n```\n\n{% tabs v-else %}\n<!-- tab Vue 2 -->\n```javascript\n<script>\nexport default {\n  data() {\n    return {\n      isVisible: false\n    };\n  },\n  methods: {\n    toggle() {\n      this.isVisible = !this.isVisible;\n    }\n  }\n};\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 -->\n```javascript\n<script>\nimport { ref } from 'vue';\n\nexport default {\n  setup() {\n    const isVisible = ref(false);\n\n    const toggle = () => {\n      isVisible.value = !isVisible.value;\n    };\n\n    return {\n      isVisible,\n      toggle\n    };\n  }\n};\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 語法糖 -->\n```javascript\n<script setup>\nimport { ref } from 'vue';\n\nconst isVisible = ref(false);\n\nconst toggle = () => {\n  isVisible.value = !isVisible.value;\n};\n</script>\n```\n<!-- endtab -->\n{% endtabs %}\n\n在這個範例中，當 `isVisible` 為 `false` 時，`v-else` 將顯示替代文本。\n\n![v-if & v-else](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fv-if%20%26%20v-else.gif?alt=media&token=76d8a423-1125-4fbd-b134-33d6b82b77c3)\n\n## `v-else-if`\n\n`v-else-if` 讓你可以在多個條件之間進行檢查。它必須在 `v-if` 或 `v-else` 的元素之後使用。\n\n```html\n<template>\n  <div>\n    <button @click=\"setStatus('A')\">狀態 A</button>\n    <button @click=\"setStatus('B')\">狀態 B</button>\n    <button @click=\"setStatus('C')\">狀態 C</button>\n    \n    <p v-if=\"status === 'A'\">當前狀態是 A。</p>\n    <p v-else-if=\"status === 'B'\">當前狀態是 B。</p>\n    <p v-else>當前狀態是 C。</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      status: 'C'\n    };\n  },\n  methods: {\n    setStatus(newStatus) {\n      this.status = newStatus;\n    }\n  }\n};\n</script>\n```\n\n{% tabs nextTick %}\n<!-- tab Vue 2 -->\n```javascript\n<script>\nexport default {\n  data() {\n    return {\n      status: 'C'\n    };\n  },\n  methods: {\n    setStatus(newStatus) {\n      this.status = newStatus;\n    }\n  }\n};\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 -->\n```javascript\n<script>\nimport { ref } from 'vue';\n\nexport default {\n  setup() {\n    const status = ref('C');\n\n    const setStatus = (newStatus) => {\n      status.value = newStatus;\n    };\n\n    return {\n      status,\n      setStatus\n    };\n  }\n};\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 語法糖 -->\n```javascript\n<script setup>\nimport { ref } from 'vue';\n\nconst status = ref('C');\n\nconst setStatus = (newStatus) => {\n  status.value = newStatus;\n};\n</script>\n```\n<!-- endtab -->\n{% endtabs %}\n\n在這個範例中，根據按下的按鈕修改 `status` 的值，並顯示相應的文本。\n\n![v-if & v-else & v-else-if](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fv-if%20%26%20v-else%20%26%20v-else-if.gif?alt=media&token=a84287ec-21a5-44cb-b5a5-2809fdf1ca14)\n\n## 總結\n\n- `v-if` 用於條件渲染，如果條件成立則顯示元素。\n- `v-else` 用於在 `v-if` 條件不成立時顯示替代內容。\n- `v-else-if` 可以用於多重條件判斷，允許在多個條件之間進行選擇。\n\n這些指令的組合使得 Vue.js 的條件渲染變得非常靈活與強大，讓你能夠根據不同的情境控制顯示內容。希望這些範例能幫助你更好地理解如何在 Vue.js 中使用 `v-if`、`v-else` 和 `v-else-if`！\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue 中的 v-for","url":"/vue/for-loop/","content":"\n## 前言\n\n在 Vue.js 中，`v-for` 指令用於在模板中渲染列表。它可以輕鬆地根據數組或對象生成多個元素，並支持渲染各種類型的資料結構。\n\n## 基本語法\n\n`v-for` 的基本語法如下：\n\n```html\nv-for=\"(item, index) in items\"\n```\n\n- `item`：當前迭代的元素。\n- `index`：當前元素的索引（可選）。\n- `items`：要迭代的數組或對象。\n\n### 搭配 `key`\n\n使用 `v-for` 時，必須為每個項目提供唯一的 `key`，以便 Vue 更高效地進行 DOM 更新。`key` 必須是唯一且不重複的值。基本語法如下：\n\n```html\nv-for=\"(item, index) in items\" :key=\"item.id\"\n```\n\n### `key` 的重要性\n\n1. **提升性能**：使用 `key` 可以幫助 Vue 更智能地重用和重新排序元素，從而減少不必要的 DOM 操作。\n2. **保持狀態**：當列表項目包含狀態（如輸入框內容）時，`key` 可確保狀態不會丟失。\n3. **減少重渲染**：在列表項目添加、刪除或重新排序時，`key` 使更新更精確。\n\n## 範例\n\n以下是 2 個簡單的範例，資料源分別是 `陣列` 與 `物件` 的格式，展示如何使用 `v-for` 渲染一個水果清單。\n\n### 陣列用法\n\n```html\n<template>\n  <div>\n    <h1>水果清單</h1>\n    <ul>\n      <li v-for=\"(item, index) in fruits\" :key=\"index\">\n        {{ index + 1 }}：{{ item }}\n      </li>\n    </ul>\n  </div>\n</template>\n```\n\n{% tabs v-for Array %}\n<!-- tab Vue 2 -->\n```javascript\n<script>\nexport default {\n  data() {\n    return {\n      fruits: ['蘋果', '香蕉', '橙子', '葡萄']\n    };\n  }\n};\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 -->\n```javascript\n<script>\nimport { ref } from 'vue';\n\nexport default {\n  setup() {\n    const fruits = ref(['蘋果', '香蕉', '橙子', '葡萄']);\n\n    return {\n      fruits,\n    };\n  }\n};\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 語法糖 -->\n```javascript\n<script setup>\n\nimport { ref } from 'vue';\n\nconst fruits = ref(['蘋果', '香蕉', '橙子', '葡萄']);\n\n</script>\n```\n<!-- endtab -->\n{% endtabs %}\n\n![v-for Array](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fv-for%20Array.png?alt=media&token=df56e4a8-a3e1-4d1a-b0af-03f0e30bfda9)\n\n### 物件用法\n\n```html\n<template>\n  <div>\n    <h1>水果清單</h1>\n    <ul>\n      <li v-for=\"(color, fruit) in fruits\" :key=\"fruit\">\n        {{ fruit }} 是 {{ color }}\n      </li>\n    </ul>\n  </div>\n</template>\n```\n\n{% tabs v-for Object %}\n<!-- tab Vue 2 -->\n```javascript\n<script>\nexport default {\n  data() {\n    return {\n      fruits: {\n        apple: '紅色',\n        banana: '黃色',\n        orange: '橙色',\n        grape: '紫色'\n      }\n    };\n  }\n};\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 -->\n```javascript\n<script>\nimport { reactive } from 'vue';\n\nexport default {\n  setup() {\n    const fruits = reactive({\n      apple: '紅色',\n      banana: '黃色',\n      orange: '橙色',\n      grape: '紫色'\n    });\n\n    return {\n      fruits,\n    };\n  }\n};\n</script>\n```\n<!-- endtab -->\n<!-- tab Vue 3 語法糖 -->\n```javascript\n<script setup>\nimport { reactive } from 'vue';\n\nconst fruits = reactive({\n  apple: '紅色',\n  banana: '黃色',\n  orange: '橙色',\n  grape: '紫色'\n});\n</script>\n```\n<!-- endtab -->\n{% endtabs %}\n\n![v-for Object](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fv-for%20Object.png?alt=media&token=e8b36af0-10db-4bdd-ab25-0984e2f4bf0f)\n\n## 總結\n\n`v-for` 是 Vue.js 中非常強大的指令，用於動態生成列表。無論是數組還是對象，它都能輕鬆處理，並且能夠有效地跟蹤元素的變化。希望這篇筆記能幫助你更好地理解和使用 `v-for`！\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue Methods 與 Computed 的使用情境","url":"/vue/vue-methods-vs-computed/","content":"\n## 使用情境\n\n- **Computed**:\n  - 用於監控資料變動，自動重新運算並更新畫面顯示。\n  - 通常不會直接修改資料，只會回傳可供呈現的數據。\n  - 例如：計算總價、過濾列表等。\n\n- **Methods**:\n  - 是需要明確觸發的函式，用於處理互動行為。\n  - 通常會用來修改資料內容，或執行一次性操作。\n  - 例如：點擊按鈕後增加數量、提交表單等。\n\n## 效能考量\n\n- 在資料量較大時，`computed` 的效能可能會受到影響。\n  - 每當相關資料變動時，會自動重新計算，這可能導致頻繁的運算，尤其在資料量龐大時。\n  \n- 使用 `methods` 可以有效減少不必要的計算。\n  - 因為 `methods` 只有在被明確呼叫時才執行，這樣可以避免過度運算，特別是在資料量大的情況下。\n\n## 總結\n\n選擇 `computed` 或 `methods` 取決於你的需求。\n\n如果需要自動更新的計算結果，使用 `computed`；如果需要執行互動操作或修改資料，則應選擇 `methods`。在大量資料的情境下，適當使用 `methods` 可以提升應用效能。\n","tags":["Vue"],"categories":["Vue"]},{"title":"解決 non-passive 事件監聽器警告","url":"/vue/non-passive-warning/","content":"\n## 前言\n\n在 Vue 應用中，處理事件監聽器的 passive 設置是提高性能的一個關鍵方面。這篇文章介紹兩種方法來解決 non-passive 事件監聽器的警告。\n\n## 方法一：使用 `.passive` 修飾符\n\n在事件監聽器上添加 `.passive` 修飾符，可以直接解決警告。例如：\n\n```vue\n@mouseleave.passive=\"leave\"\n```\n\n這種方法簡單且有效，適合大多數情況。\n\n## 方法二：使用 `default-passive-events` 套件\n\n如果需要更全面的解決方案，可以使用 `default-passive-events` 套件。以下是使用步驟：\n\n1. 安裝套件：\n\n   ```bash\n   npm install default-passive-events --save\n   ```\n\n2. 在 `main.js` 中引入套件：\n\n   ```javascript\n   import 'default-passive-events';\n   ```\n\n### 注意事項\n\n`default-passive-events` 套件能有效處理瀏覽器的事件默認行為，特別是 `touchstart` 和 `touchmove` 事件，從而提高頁面的滑動性能。然而，這個方法在某些情況下可能會引發錯誤，例如當頁面上沒有可滑動的元素時：\n\n![default-passive-events error](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fdefault-passive-events%20error.gif?alt=media&token=114c7f85-0479-4ccf-9eaf-547c01a65c28)\n\n如果您的頁面包含可滑動元素，請在使用此方法時保持警惕，以免影響用戶體驗。\n\n通過以上兩種方法，您可以有效解決 non-passive 事件監聽器的警告，並提升應用的性能。\n","tags":["JavaScript","Vue"],"categories":["Vue"]},{"title":"共用 Vue 專案的 node_modules","url":"/vue/vue-shared-node-modules/","content":"\n## 目標\n\n在多個專案中節省空間，同時確保共用相同的 `node_modules` 資源。\n\n## 優化方法\n\n以下是簡單的結構說明及 CMD 指令的使用方法。\n\n### 1. 專案結構\n\n確保 A 專案中已建立 `node_modules`，而其他專案則可不必重複建立。\n\n- A\n  - `node_modules`\n  - 專案資料\n- B\n  - 專案資料\n\n![專案結構](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fproject%20node_modules.png?alt=media&token=ad578843-1352-4262-8c5e-492c9a431981)\n\n### 2. 使用 CMD 創建符號連結\n\n1. 以系統管理員身分開啟 CMD。\n2. 切換至 B 專案的資料夾（使用 `cd B 專案路徑`）。\n3. 創建符號連結，指向 A 專案的 `node_modules`（執行 `mklink /D node_modules ..\\A\\node_modules`）。\n\n這樣便會在 B 專案中建立一個指向 A 專案 `node_modules` 的符號連結。\n\n### 3. 完成檢查\n\n檢查後發現，檔案大小並未改變，顯示已成功共用 `node_modules`。\n\n![完成圖](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2Fproject%20node_modules%20completed.png?alt=media&token=3abfa1fc-bcbc-4ff8-a536-1739452af7f6)\n\n透過上述方法，您可以有效地在不同的 Vue 專案之間共用 `node_modules`，達到節省空間和提高效率的目的。\n","tags":["Vue"],"categories":["Vue"]},{"title":"解決 Vue CLI 版本確認問題","url":"/vue/vue-cli-version-check/","content":"\n當你使用指令 `vue -v` 或 `vue --version` 時，若出現以下錯誤訊息：\n\n```powershell\nvue : 因為這個系統上已停用指令碼執行，所以無法載入檔案 C:\\Users\\User\\AppData\\Roaming\\npm\\vue.ps1 檔案。\n```\n\n![Vue-CLI version check error](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2FVue-CLI%20version%20check%20error.png?alt=media&token=f65689a3-8c39-45a9-99aa-e65adde3c925)\n\n## 解決方法\n\n1. **以管理員身份運行 PowerShell**\n   - 確保您以管理員身份啟動 PowerShell，這對執行後續命令至關重要。\n\n2. **檢查當前執行策略**\n   - 在 PowerShell 中執行以下命令：\n\n     ```powershell\n     Get-ExecutionPolicy\n     ```\n\n   - 如果返回值是 `Restricted`，表示當前執行策略不允許執行任何腳本。\n\n3. **修改執行策略**\n   - 執行以下命令以更改執行策略：\n\n     ```powershell\n     Set-ExecutionPolicy RemoteSigned\n     ```\n\n   - 當系統提示時，輸入 `Y` 以確認更改。\n\n## 注意事項\n\n- 請務必以管理員身份運行 PowerShell，而不是 CMD 窗口，以確保這些命令能正確執行。\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue 2 與 Vue 3 差別","url":"/vue/vue-2-vs-vue-3-differences/","content":"\n## 生命週期的變化\n\n|    Vue 2.x     |     Vue 3     |\n| ------------- | ------------ |\n| beforeCreate  | 使用 setup() |\n| created       | 使用 setup() |\n| beforeMount   | onBeforeMount |\n| mounted       | onMounted |\n| beforeUpdate  | onBeforeUpdate |\n| updated       | onUpdated |\n| beforeDestroy | onBeforeUnmount |\n| destroyed     | onUnmounted |\n| errorCaptured | onErrorCaptured |\n\n## 使用 Proxy 取代 defineProperty\n\n在 Vue 2 中，雙向綁定的核心是使用 `Object.defineProperty()`，這導致了一些限制。以下是兩者的對比：\n\n- **Object.defineProperty() 的限制**\n  - 只能在物件的初始定義時監聽屬性，對於後來新增的屬性無法自動監聽。\n  - 對於陣列，操作的監聽也相對複雜，需使用額外的方法來監控變更。\n\n  **範例：**\n\n  ```javascript\n  Object.defineProperty(Obj, 'name', {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n          return this._name;\n      },\n      set: function (val) {\n          this._name = val;\n      }\n  });\n  ```\n\n- **Proxy 的優勢**\n  - `Proxy` 允許我們直接攔截對物件的讀取和寫入操作，並可以針對整個物件進行監控，而不僅僅是單個屬性。\n  - 使得我們能夠更靈活地設置監聽器，並且可以動態監聽新增屬性。\n\n  **範例：**\n\n  ```javascript\n  const handler = {\n      get: function(obj, prop) {\n          return prop in obj ? obj[prop] : '屬性不存在';\n      },\n      set: function(obj, prop, value) {\n          obj[prop] = value;\n          return true;\n      }\n  };\n  const p = new Proxy({}, handler);\n  p.a = 1;\n  console.log(p.a); // 1\n  console.log(p.b); // '屬性不存在'\n  ```\n\n這樣的改變使得 Vue 3 的響應系統更為強大與高效，能夠隨時監控物件的變更，並且大大簡化了程式碼。\n\n## Composition API\n\nVue 3 引入了 Composition API，這是一種新的組件設計方式，使得邏輯重用變得更簡單。相比於 Vue 2 的 Options API，Composition API 讓開發者可以更靈活地組織代碼。\n\n## TypeScript 支持\n\nVue 3 更加優化了對 TypeScript 的支持，讓開發者能夠更輕鬆地進行類型檢查，從而提升代碼質量和開發效率。\n\n## Fragment\n\nVue 3 引入了片段（Fragments）功能，允許一個組件返回多個根節點，從而簡化組件結構，減少不必要的包裹元素。\n\n```html\n<!-- Vue 2 -->\n<template>\n  <div>\n    <div>...</div>\n    <div>...</div>\n  </div>\n</template>\n\n<!-- Vue 3 -->\n<template>\n  <div>...</div>\n  <div>...</div>\n</template>\n```\n\n## 瀏覽器相容性\n\nVue 2.x 在 IE 上還有支援，而 Vue 3 使用了 `Proxy` 在 IE 之外的主要瀏覽器中都有很好的支援。因此，Vue 3 放棄了對 IE 的支援，符合現代開發的需求。\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue 中的事件處理與修飾符指南","url":"/vue/event-handling-and-modifiers/","content":"\n## v-on\n\n`v-on` 指令用於綁定事件，與 jQuery 的 `on` 方法類似，但 Vue 直接在 HTML 元素上進行綁定。\n\n### jQuery 寫法\n\n```javascript\n$('xxx').on('click', function() {\n  // 事件處理邏輯\n});\n```\n\n### Vue 寫法\n\n```html\n<!-- 未縮寫 -->\n<button class=\"btn btn-primary\" v-on:click=\"reverseText\">反轉字串</button>\n\n<!-- 縮寫 -->\n<button class=\"btn btn-primary\" @click=\"reverseText\">反轉字串</button>\n```\n\n### 實作範例\n\n```html\n<div id=\"app\">\n  <input type=\"text\" class=\"form-control\" v-model=\"text\">\n  <button class=\"btn btn-primary mt-1\" v-on:click=\"reverseText\">反轉字串</button>\n  <div class=\"mt-3\">\n    {{ newText }}\n  </div>\n</div>\n\n<script>\nvar app = new Vue({\n  el: '#app',\n  data: {\n    text: '',\n    newText: '' // 儲存反轉後的字串\n  },\n  methods: {\n    reverseText: function() {\n      this.newText = this.text.split('').reverse().join('');\n    }\n  }\n});\n</script>\n```\n\n![Vue reverse text](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2FVue%20reverse%20text.png?alt=media&token=ab05533c-2906-4b04-8b4d-b552be0f3206)\n\n## 事件修飾符\n\n- **stop**：阻止事件向上冒泡。\n- **prevent**：阻止元素的預設事件。\n- **capture**：在冒泡過程中，先觸發帶有該修飾符的元素。\n- **self**：僅觸發自身範圍內的事件，不包含子元素。\n- **once**：事件僅觸發一次，第二次點擊不會再觸發，但不會阻止冒泡。\n\n## 按鍵修飾符\n\n- **enter**\n- **tab**\n- **delete**：包括 `delete` 和 `backspace` 鍵。\n- **esc**\n- **space**\n- **up**\n- **down**\n- **left**\n- **right**\n- **ctrl**\n- **alt**\n- **shift**\n- **meta**\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue 中的 v-text、v-model、v-html 和 v-bind","url":"/vue/data-binding/","content":"\n## 雙向綁定：v-text、v-model 和 v-html\n\n- **v-text**：將 `data` 中的 `messageText` 插入到 `<div>` 中。\n- **v-model**：用於 `input` 元素，實現數據的雙向綁定，允許用戶修改 `data` 中的資料。\n- **v-html**：允許在 `data` 中插入 HTML 標籤，並在畫面中渲染。\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n\n<div id=\"app\">\n  {{ message }}\n  <div v-text=\"messageText\"></div>\n  <div v-html=\"messagehtml\"></div>\n  <input type=\"text\" v-model=\"message\">\n</div>\n\n<script>\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: '我是 message',\n    messageText: '我是 messageText',\n    messagehtml: '<h3>哈囉 HTML</h3>'\n  }\n})\n</script> \n```\n\n![Vue data binding](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Vue%2FVue%20data%20binding.png?alt=media&token=cb9c558e-eb36-41a1-bcda-f10b6be2c9d2)\n\n## 使用 v-bind\n\n- **v-bind**：用來動態綁定 HTML 屬性。可以使用縮寫 `:` 來簡化語法。\n\n```html\n<div id=\"app\">\n    <!-- 使用 v-bind 綁定圖片來源和類名 -->\n\n    <!-- 未縮寫 -->\n    <img v-bind:src=\"imgSrc\" alt=\"\"  v-bind:class=\"className\">\n    \n    <!-- 縮寫 -->\n    <img :src=\"imgSrc\" alt=\"\" :class=\"className\">\n</div>\n\n<script>\nvar app = new Vue({\n  el: '#app',\n  data: {\n    imgSrc: 'https://images.unsplash.com/photo-1479568933336-ea01829af8de?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=d9926ef56492b20aea8508ed32ec6030&auto=format&fit=crop&w=2250&q=80',\n    className: 'img-fluid'\n  }\n})\n</script>\n```\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue 生命週期","url":"/vue/lifecycle/","content":"\n## 生命週期階段\n\nVue 的生命週期可以分為幾個主要階段：\n\n## 1. 創建階段\n\n- **`beforeCreate`**\n\n  在 Vue 實例或組件初始化後，數據觀察和事件監聽器的設置尚未完成。此時，無法讀取任何自定義資料（如 computed 和 methods）。\n\n- **`created`**\n\n  在完成數據觀察、computed 和 methods 初始化後，實例已經創建，資料可被讀取，屬性已經綁定，但 DOM 尚未生成。\n\n## 2. 掛載階段\n\n- **`beforeMount`**\n\n  在掛載開始之前被調用，相關的虛擬 DOM 尚未被渲染。\n\n- **`mounted`**\n\n  組件已經掛載到 DOM 中，這裡可以執行需要操作 DOM 的代碼（例如使用 jQuery）。\n\n## 3. 更新階段\n\n- **`beforeUpdate`**\n\n  在數據更新之前被調用，發生在虛擬 DOM 重新渲染之前。此時可以在這個鉤子中改變狀態，並不會觸發額外的重新渲染過程。\n\n- **`updated`**\n\n  當數據發生修改或新增時，由於數據更改會導致虛擬 DOM 重新渲染，此鉤子會在更新後被呼叫。\n\n## 4. 銷毀階段\n\n- **`beforeDestroy`** (整個生命週期最後可操作資料的地方)\n  實例銷毀之前被調用。在此階段，實例仍可完全使用，可以用來關閉計時器、移除自訂事件監聽等。\n\n- **`destroyed`**\n  Vue 實例銷毀後被呼叫。此時所有與實例相關的資料會被解綁定，所有事件監聽器會被移除，所有子實例也會被銷毀。該鉤子在服務器端渲染期間不會被呼叫。\n\n## 生命週期圖\n\n以下是官網提供的圖片\n\n![Vue 生命週期圖](https://zh-hk.vuejs.org/assets/lifecycle_zh-CN.W0MNXI0C.png)\n\n## 實例代碼\n\n以下是一個簡單的 Vue 實例，演示了生命週期鉤子的使用：\n\n```javascript\nnew Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue!'\n  },\n  beforeCreate() {\n    console.log('beforeCreate: 實例被創建');\n  },\n  created() {\n    console.log('created: 實例已創建');\n  },\n  beforeMount() {\n    console.log('beforeMount: 開始掛載');\n  },\n  mounted() {\n    console.log('mounted: 組件已掛載');\n  },\n  beforeUpdate() {\n    console.log('beforeUpdate: 更新之前');\n  },\n  updated() {\n    console.log('updated: 更新之後');\n  },\n  beforeDestroy() {\n    console.log('beforeDestroy: 銷毀之前');\n  },\n  destroyed() {\n    console.log('destroyed: 組件已銷毀');\n  }\n});\n```\n\n## 結論\n\n了解 Vue 的生命週期對於開發者來說非常重要，這不僅有助於提高代碼的性能，還能使得代碼的結構更加清晰。透過生命週期鉤子，我們可以在適當的時候進行初始化、更新和清理工作，從而更好地控制組件的行為。\n","tags":["Vue"],"categories":["Vue"]},{"title":"如何優化 Hexo SEO","url":"/hexo/optimize-seo/","content":"\n## 前言\n\n在現今數位化的世界中，網站的可見度至關重要。若你的網站使用 Hexo 作為靜態網站生成器，這裡有一些實用的 SEO 優化技巧，幫助你提高搜索引擎的排名。\n\n## Google Search Console\n\nGoogle Search Console 是一個功能強大的工具，可以幫助你監控和維護網站在 Google 搜索結果中的表現。\n這個平台讓你能夠查看網站的索引狀態、搜索流量和用戶點擊數據，這些資訊能指導你調整內容和策略，進而提高 SEO 表現。\n\n詳細請看 <a href=\"/seo/google-search-console\" target=\"_blank\" rel=\"noopener noreferrer\">為你的網站加入 Google Search Console</a> 這篇文章。\n\n## robots.txt\n\n`robots.txt` 是一個用來指導搜索引擎機器人如何抓取你網站的文件。確保你的 Hexo 網站中包含正確配置的 `robots.txt`，以明確告訴搜索引擎哪些頁面應被抓取，哪些頁面應被忽略。這樣可以有效防止不必要的頁面被索引，並將搜索引擎的注意力集中在重要的內容上。\n\n以下是我網站的 `robots.txt` 設定範例：\n\n```bash\nUser-agent: *\nAllow: /\nAllow: /archives/\nAllow: /categories/\nAllow: /tags/\nDisallow: /vendors/\nDisallow: /fonts/\nDisallow: /fancybox/\nSitemap: https://asz8621.github.io/sitemap.xml\nSitemap: https://asz8621.github.io/baidusitemap.xml\n```\n\n**設定說明：**\n\n- User-agent: 這表示規則適用於所有搜索引擎機器人。\n- Allow: 這些路徑允許搜索引擎抓取，讓重要的內容能被索引。\n- Disallow: 這些路徑禁止搜索引擎抓取，保護不必要的或敏感的資料。\n- Sitemap: 提供網站地圖的鏈接，幫助搜索引擎更好地了解你的網站結構。\n\n## sitemap 網站地圖\n\n網站地圖（sitemap）是幫助搜索引擎發現和索引網站頁面的關鍵工具。為你的 Hexo 網站生成 XML 網站地圖並提交至 Google Search Console，可以確保搜索引擎快速找到並索引所有重要頁面，從而提升網站的可見度。\n\n要生成網站地圖，你可以安裝以下套件：\n\n```bash\nnpm install hexo-generator-sitemap --save\nnpm install hexo-generator-baidu-sitemap --save\n```\n\n這些套件將在你執行 `hexo deploy` 時自動生成網站地圖，確保每次更新後網站地圖都是最新的。\n\n如需更詳細的設定，請參考以下文檔：[hexo-generator-sitemap 說明](https://github.com/hexojs/hexo-generator-sitemap?tab=readme-ov-file#options)。\n\n如果你還沒使用過 sitemap，可以看看 <a href=\"/seo/sitemap\" target=\"_blank\" rel=\"noopener noreferrer\">為你的網站建立 Sitemap 網站地圖</a> 這篇文章。\n\n## nofollow 標籤\n\n在某些情況下，你可能希望指導搜索引擎不要跟蹤特定的鏈接。這時候可以使用 `nofollow` 標籤。對於不希望提升其排名的外部鏈接或付費鏈接，可以在 HTML 中添加 `rel=\"nofollow\"` 屬性。這將告訴搜索引擎不要將這些鏈接計入排名考量。\n\n## 壓縮檔案\n\n網站加載速度對 SEO 影響深遠。使用 Gzip 壓縮技術可以有效減少網站檔案大小，從而加快頁面加載速度，提升用戶體驗。Hexo 提供多個插件，輕鬆實現檔案壓縮，建議安裝相關插件以優化網站性能。\n\n### 推薦插件\n\n- [hexo-all-minifier](https://github.com/chenzhutian/hexo-all-minifier)\n- [hexo-neat](https://github.com/ohroy/hexo-neat)\n\n## Google Analytics\n\n最後，整合 Google Analytics 到你的 Hexo 網站可以幫助你跟蹤訪問者的行為。透過這些數據，你可以獲得有關訪問來源、停留時間及用戶互動等詳細資訊，進一步調整和優化你的內容策略。\n\n如果你還沒使用過 Google Analytics，可以看看 <a href=\"/seo/google-analytics\" target=\"_blank\" rel=\"noopener noreferrer\">為你的網站加入 Google Analytics</a> 這篇文章，會教你如何申請 Google Analytics。\n\n## 結論\n\n透過上述方法，你可以顯著提升你的 Hexo 網站的 SEO 表現。持續關注網站的數據並不斷調整策略，將有助於你在競爭激烈的數位市場中脫穎而出。立即開始優化，讓你的網站更具可見性！\n","tags":["Hexo","SEO"],"categories":["Hexo"]},{"title":"為你的網站加入 Google Analytics","url":"/seo/google-analytics/","content":"\n## Google Analytics 申請步驟\n\n### 登入你的 Google 帳戶\n\n首先，請登入你的 Google 帳戶，然後前往 [Google Analytics 網頁](https://analytics.google.com/analytics/web/?authuser=0#/provision/create)。\n\n### 建立帳戶\n\n填寫帳戶名稱以創建新的 Google Analytics 帳戶。帳戶名稱可以隨意設置，後續也可進行修改。\n\n![Google Analytics application steps 1](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/SEO%2FGoogle%20Analytics%20application%20steps%201.png?alt=media&token=95f08f3e-1b1f-442a-8fbd-48a1d18f5677)\n\n### 建立資源\n\n在 `屬性名稱` 中輸入你的網站名稱，並選擇適當的時區與貨幣。\n\n![Google Analytics application steps 2](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/SEO%2FGoogle%20Analytics%20application%20steps%202.png?alt=media&token=9e1a10dd-df18-455c-9adf-40f8d4739d52)\n\n### 商家詳細資料\n\n選擇你的網站產業類別及商家規模。\n\n![Google Analytics application steps 3](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/SEO%2FGoogle%20Analytics%20application%20steps%203.png?alt=media&token=de5ee5bf-5c07-441a-a7d6-17a751b4ade4)\n\n### 設定業務目標\n\n選擇適合你的網站的業務目標。\n\n![Google Analytics application steps 4](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/SEO%2FGoogle%20Analytics%20application%20steps%204.png?alt=media&token=4bf9cb36-c8e0-4222-9876-e19302a56ef7)\n\n### 同意服務合約\n\n仔細閱讀並同意 Google Analytics 的服務合約。\n\n![Google Analytics application steps 5](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/SEO%2FGoogle%20Analytics%20application%20steps%205.png?alt=media&token=9d0e4fd5-d10e-4175-8bed-483374b38a5a)\n\n### 資料收集\n\n根據你的專案需求，這邊請先選擇 `網站` 作為主要資料收集的來源。\n\n![Google Analytics application steps 6](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/SEO%2FGoogle%20Analytics%20application%20steps%206.png?alt=media&token=ec8a2c3e-ff5c-4c45-8694-fd4d1d151f78)\n\n### 設定資料串流\n\n在此步驟中，填入你的網站網址，確保選擇 HTTPS，串流名稱為你的網站名稱。\n\n![Google Analytics application steps 7](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/SEO%2FGoogle%20Analytics%20application%20steps%207.png?alt=media&token=a4718494-4d59-4070-8077-315186ff3b0a)\n\n### 塞入 GA 程式碼\n\n將生成的追蹤代碼複製並粘貼到網站的 `<head>` 標籤中。\n\n在 Hexo 中，這段代碼通常位於 `themes\\next\\layout\\_layout.njk` 文件中。修改完成後，將更改上傳至 GitHub，然後點擊「測試安插狀態」。\n\n![Google Analytics application steps 8](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/SEO%2FGoogle%20Analytics%20application%20steps%208.png?alt=media&token=308dad9f-9a94-4134-bdb4-b6720a8f86f0)\n\n### 前往 Google Analytics\n\n完成以上步驟後，前往 [Google Analytics](https://analytics.google.com) 查看你的數據。\n\n如果你看到如下畫面，恭喜你，已成功申請並設置 Google Analytics！\n\n![Google Analytics application steps 9](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/SEO%2FGoogle%20Analytics%20application%20steps%209.png?alt=media&token=967b5340-e315-48cf-9d1c-7d962e831087)\n","tags":["SEO"],"categories":["SEO"]},{"title":"為你的網站加入 Google Search Console","url":"/seo/google-search-console/","content":"\n## 前言\n\nGoogle Search Console 是一個功能強大的工具，幫助你監控和優化網站在 Google 搜索結果中的表現。透過這個平台，你可以獲取網站的索引狀態、搜索流量和用戶點擊數據，這些資訊將指導你調整內容和策略，進而提升 SEO 效果。\n\n在這篇文章中，我將以我的部落格為例，逐步介紹如何將網站加入 Google Search Console，讓你能夠有效追蹤網站表現，提升搜尋引擎排名。\n\n## 登入 Google Search Console\n\n前往 [Google Search Console](https://search.google.com/search-console/about) 並登入你的 Google 帳戶。\n\n## 設定網址\n\n在進入主頁面後，按照以下步驟設定你的網址：\n\n1. 選擇 `網址前置字元`。\n\n2. 輸入你的 Hexo 部落格網址。\n\n![Google Search Console Settings](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGoogle%20Search%20Console%20Settings.png?alt=media&token=a164f25c-af9d-482a-88b8-5a86c15dacf6)\n\n## 上傳 HTML 檔案，並驗證網站\n\n1. 點擊下載 .html 檔案。\n\n2. 將檔案放入專案的 `source` 資料夾中。\n\n3. 執行以下命令將檔案上傳到 GitHub：\n\n   ```bash\n   hexo clean && hexo deploy\n   ```\n\n4. 上傳完畢後就點選 `驗證`\n\n![Google Search Console upload HTML](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGoogle%20Search%20Console%20upload%20HTML.png?alt=media&token=6cf88d88-1014-4eaa-8ffb-18e5d3f2a6e2)\n\n## 完成設定\n\n成功驗證後，你將跳轉到另一個頁面，並可以查看網站的表現數據，包括上傳 Sitemap 等功能。\n\n![Google Search Console Menu](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/SEO%2FGoogle%20Search%20Console%20Menu.png?alt=media&token=01c0eb2b-4fe0-4f8f-a0df-12670145e9cb)\n\n## 結語\n\n加入 Google Search Console 並完成網站驗證後，你將能夠獲取網站在 Google 搜索中的詳細數據，這對於提高網站的可見性和流量至關重要。持續監控這些數據，並根據得到的見解進行網站優化，將會顯著提升你的網站性能，並促進業務增長。希望這篇文章能幫助你順利完成設置，開啟網站 SEO 管理之旅。\n","tags":["SEO"],"categories":["SEO"]},{"title":"為你的網站建立 Sitemap 網站地圖","url":"/seo/sitemap/","content":"\n## 前言\n\n網站地圖（Sitemap）是提升 SEO 效能的重要工具，能夠幫助搜尋引擎更有效地抓取和索引網站內容，透過網站地圖搜尋引擎才能迅速理解網站的結構及其各個頁面的重要性。\n\n本文將帶你使用各種工具來生成和管理網站地圖，以確保你的網站在搜尋結果中保持競爭力。\n\n## 生成工具\n\n以下是一些推薦的工具和套件，可幫助你輕鬆建立網站地圖：\n\n1. **XML-Sitemaps.com**\n\n   網址：[XML-Sitemaps.com](https://www.xml-sitemaps.com/)\n\n   這是一個線上生成 sitemaps 的網站，輸入你網站的 URL，就會自動生成網站地圖。\n\n   你可以下載生成的XML檔案，然後上傳至網站根目錄，確保搜尋引擎能輕鬆找到並讀取網站結構。\n\n2. **Hexo**\n\n   如果你是使用 Hexo 可以透過安裝以下套件自動生成網站地圖：\n\n   ```bash\n   npm install hexo-generator-sitemap --save\n   npm install hexo-generator-baidu-sitemap --save\n   ```\n\n   這些套件會在每次執行 `hexo deploy` 時自動生成網站地圖，確保網站內容更新後，網站地圖也能同步更新。\n\n   若需詳細設定，請參考這裡的說明：[hexo-generator-sitemap 說明](https://github.com/hexojs/hexo-generator-sitemap?tab=readme-ov-file#options)。\n\n## 提交 sitemap\n\n如果還沒有用過 Google Search Console 可以看看 <a href=\"/seo/google-search-console\" target=\"_blank\">為你的網站加入 Google Search Console</a> 這篇文章。\n\n在更新網站內容後，記得提交網站地圖，這樣才能確保搜尋引擎爬蟲能夠抓取到新增的頁面。\n\n可以通過 Google Search Console 提交你的網站地圖，確保網址的正確性與可存取性。\n\n![Google Search Console Sitemap](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/SEO%2FGoogle%20Search%20Console%20Sitemap.png?alt=media&token=abc7ac3e-8282-4591-9a83-86a74fbe97c0)\n\n## 結論\n\n建立和維護一個有效的網站地圖不僅能提升網站的 SEO，還能使使用者和搜尋引擎更輕鬆地導航你的網站。通過使用上述工具和方法確保網站地圖始終保持最新，提高網站在搜尋引擎中的可見性。無論你是新手網站管理者還是經驗豐富的 SEO 專家，定期檢查和更新網站地圖都是不可或缺的重要實踐。\n","tags":["SEO"],"categories":["SEO"]},{"title":"如何在 Google Chrome 中阻止網頁彈出自動翻譯框","url":"/browser/disable-google-translate-box/","content":"\n## 前言\n\n在開發或已上線的網站中，Google Chrome 瀏覽器有時會自動彈出翻譯框，這不僅影響用戶體驗，還可能干擾到網站的正常運行。這篇文章將介紹如何通過簡單的 HTML 修改來阻止這一煩人的翻譯框彈出。\n\n![Google translation box](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Browser%2FGoogle%20translation%20box.png?alt=media&token=0025b6d7-4f52-400e-9c4c-9f7eab9ded4e)\n\n## 為什麼會出現自動翻譯框？\n\nGoogle Chrome 自動翻譯框通常出現在瀏覽器檢測到用戶的語言與網頁內容的語言不一致時。雖然這對某些用戶來說是方便的功能，但對於許多網站開發者和用戶來說，這可能是多餘且干擾的。\n\n## 如何防止翻譯框的出現\n\n### 1. 修改網頁語系\n\n確保在您的 HTML 文檔中正確設置 `lang` 屬性，這樣 Chrome 可以更準確地識別頁面語言。例如，如果您的網站主要使用繁體中文，可以這樣設置：\n\n```html\n<html lang=\"zh-tw\">\n```\n\n### 2. 新增 `meta` 標籤\n\n在 `<head>` 部分添加以下 `meta` 標籤，以告訴 Google 不要對該頁面進行翻譯：\n\n```html\n<meta name=\"google\" content=\"notranslate\">\n```\n\n### 完整範例\n\n將以上兩個步驟結合起來，您可以得到如下的 HTML 範例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-tw\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta name=\"google\" content=\"notranslate\">\n    <title>您的網站標題</title>\n</head>\n<body>\n    <h1>歡迎來到您的網站</h1>\n</body>\n</html>\n```\n\n## 其他考量\n\n### 針對多語言網站\n\n如果您的網站支持多種語言，您可以針對每種語言的頁面進行相應的 `lang` 設置與 `meta` 標籤的添加，確保用戶在訪問特定語言版本時不會受到翻譯框的干擾。\n\n### Chrome 瀏覽器設定\n\n除了網站的修改，用戶也可以在 Google Chrome 的設置中關閉自動翻譯功能，具體步驟如下：\n\n1. 打開 Chrome 瀏覽器。\n2. 點擊右上角的三個點，選擇「設定」。\n3. 滾動到「語言」部分，選擇「語言」。\n4. 在「語言」下，關閉「使用 Google 翻譯」的選項。\n\n![Chrome disables google translation box](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Browser%2FChrome%20disables%20google%20translation%20box.png?alt=media&token=7401ebd7-4b65-4b43-8e9c-7c29ec343d3d)\n\n## 結語\n\n透過簡單的 HTML 修改，您可以有效地阻止 Google Chrome 的自動翻譯框彈出，提升用戶的網站瀏覽體驗。這不僅對網站的設計和開發者有利，也使訪問者能夠專注於網站內容而不被不必要的干擾所打擾，希望這篇文章能幫助您解決問題。\n","tags":["Browser","Chrome"],"categories":["Browser"]},{"title":"Hexo server port 4000 has been used","url":"/hexo/port-4000-in-use/","content":"\n## 前言\n\n當你在使用 Visual Studio Code（VSCode）時，如果在多個終端機上執行相同的 hexo server 命令，可能會遇到以下錯誤：\n\n```bash\nFATAL Port 4000 has been used. Try other port instead.\nFATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html\nError: listen EADDRINUSE: address already in use :::4000\n```\n\n![Hexo port 4000 in use](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20port%204000%20in%20use.png?alt=media&token=36cd4a16-9b5f-4246-916b-322977427fc4)\n\n這是因為 hexo server 預設綁定的端口為 4000。如果你的電腦上已有其他應用程式或專案在使用該端口，就會出現這個問題。\n\n以下是幾種解決這個問題的方法：\n\n## 檢查運行中的進程\n\n在重新啟動 hexo server 之前，先確認是否有其他軟體或是專案在運行相同的端口。你可以在終端機中使用以下命令檢查端口使用情況：\n\n### 檢查指令\n\n**Windows 系統：**\n\n```bash\nnetstat -ano | findstr :4000\n```\n\n**macOS 或 Linux 系統：**\n\n```bash\nlsof -i :4000\n```\n\n如果有進程正在佔用該端口，根據顯示的 PID 終止該進程，下圖的 `20152` 就是 PID。\n\n![Hexo port 4000 list](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20port%204000%20list.png?alt=media&token=7a87f7a6-13f8-4a24-ba2c-72ba413e7d0e)\n\n### **終止指令**\n\n**Windows 系統：**\n\n```bash\ntaskkill /PID <PID> /F\n```\n\n**macOS 或 Linux 系統：**\n\n```bash\nkill -9 <PID>\n```\n\n下圖為終止端口畫面。\n\n![Hexo port 4000 close](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20port%204000%20close.png?alt=media&token=590712af-26ca-4677-b5e8-83d726c6f21e)\n\n## 使用不同的端口\n\n如果你不想終止運行中的 4000 port，可以選擇使用不同的端口來啟動服務。透過添加 `-p` 參數來指定新的端口號，例如：\n\n```bash\nhexo server -p 4001\n```\n\n這樣就能在新的端口上啟動服務，避免與其他服務衝突。\n\n## 修改 Hexo 配置文件\n\n另一種選擇是在 Hexo 的 `_config.yml` 文件中直接修改伺服器的端口設定。你可以新增以下程式碼：\n\n```yaml\nserver:\n  port: 4001\n  compress: true\n  header: true\n```\n\n這樣，hexo server 將會自動使用你指定的端口，避免未來的衝突。\n\n## 總結\n\n以上幾種方法可有效解決 hexo server 的端口衝突問題。根據你的需求選擇最合適的解決方案，可以提升開發效率，避免不必要的錯誤。如果經常遇到端口衝突的情況，建議考慮長期使用不同端口或管理運行中的端口，以確保你的工作不受干擾。\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"Web USB API 的應用範例","url":"/javascript/web-usb/","content":"\n{% note warning %}\n以下搭配 Xprinter XP-N160II 藍牙打印機來作範例。\n{% endnote %}\n\n## 取得 Vendor ID 與 Product ID\n\n在使用 Web USB API 之前，首先需要獲取設備的 Vendor ID 和 Product ID，以便進行正確的配對和連線。\n\n1. 打開 Chrome 瀏覽器，並在網址列輸入 `chrome://usb-internals/` 以查看連接的 USB 設備資訊。\n\n   ![Web USB Devices](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FWeb%20USB%20Devices.png?alt=media&token=c32d3955-ecc1-4ae4-abf5-4be35f2d8ea2)\n\n2. **Vendor ID（供應商 ID）**：同一供應商的設備會有相同的 Vendor ID，例如，不同型號的羅技滑鼠，其 Vendor ID 皆為 `0x046D`。\n\n3. **Product ID（產品 ID）**：同一型號的設備會有相同的 Product ID，例如，相同型號的羅技滑鼠，其 Product ID 皆為 `0xC247`。\n\n{% note info %}\nWeb USB API 不提供獲取所有 USB 設備的功能，因此必須先手動獲取 Vendor ID 和 Product ID，才能有效使用 API 的其他功能。\n{% endnote %}\n\n## 連線到 USB 設備\n\n本範例使用的設備為藍牙打印機，其 Vendor ID 為 `0x0483`，Product ID 為 `0x5743`。\n\n### HTML 範例\n\n```html\n<button type=\"button\" id=\"requestDevice\">USB 連接</button>\n```\n\n### JavaScript 範例\n\n以下是用於連接 USB 設備的基本 JavaScript 程式碼範例：\n\n```javascript\nconst requestDevice = document.getElementById('requestDevice');\nconst vendorId = '0x0483' // 供應商 ID (同廠商 ID 會相同)\nconst productId = '0x5743' // 產品 ID (同型號 ID 會相同)\nconst filters = [{ vendorId, productId }];\n\nrequestDevice.addEventListener('click', async () => {\n  try {\n    const devices = await navigator.usb.getDevices();\n    if (devices.length > 0) {\n      // 進行設備操作\n      console.log('已連接的設備:', devices[0]);\n    } else {\n      // 如果還沒有符合的設備，進行設備尋找\n      const device = await navigator.usb.requestDevice({ filters });\n      console.log('設備名稱:', device.productName);\n      // 進行設備操作\n    }\n  } catch (error) {\n    console.error('連接設備時出錯:', error);\n  }\n});\n```\n\n### Async/Await 版本\n\n以下是使用 Async/Await 語法的 USB 連接範例：\n\n```javascript\nlet webUSBDevice = null;\nlet isConn = false;\n\nasync function webUSBConnection() {\n  const vendorId = '0x0483'; // 供應商 ID\n  const productId = '0x5743'; // 產品 ID\n  const filters = [{ vendorId, productId }];\n\n  try {\n    const devices = await navigator.usb.getDevices();\n\n    // 綁定 USB 設備\n    if (devices.length > 0) {\n     // 如果有綁定了就指定第一個\n     webUSBDevice = devices[0]\n    } else {\n     // 如果還沒有符合的設備，進行設備尋找\n     webUSBDevice = await navigator.usb.requestDevice({ filters })\n    }\n\n    await webUSBDevice.open(); // 連接設備\n    await webUSBDevice.selectConfiguration(1); // 選擇配置\n    await webUSBDevice.claimInterface(0); // 連接接口\n\n    isConn = webUSBDevice.opened\n    console.log('USB 設備已準備就緒');\n  } catch (error) {\n    console.error('USB 配對失敗:', error);\n  }\n}\n```\n\n## 手動斷開 USB 設備連線\n\n當需要手動斷開 USB 設備連線時，可以使用以下函數：\n\n```javascript\nconst isConn = false;\n\nasync function webUSBDisconnect() {\n  if (!isConn) return; // USB 未連線不執行\n  try {\n    const devices = await navigator.usb.getDevices();\n    devices.forEach(async device => {\n      // device 裡面的 vendorId、productId 為十禁制 vendorId、productId 皆為十六禁制所以需要轉換比對\n      const deviceVendorId16 = parseInt(vendorId, 16);\n      const deviceProductId16 = parseInt(productId, 16);\n      const deviceVendorId = device.vendorId;\n      const deviceProductId = device.productId;\n      \n      // 如果與設備相符就斷線\n      if (deviceVendorId16 === deviceVendorId && deviceProductId16 === deviceProductId) {\n        await device.close();\n      }\n      \n      isConn = await device.opened;\n    });\n  } catch (error) {\n    console.error('斷開設備時出錯:', error);\n  }\n}\n```\n\n## 瀏覽器支援狀況\n\nWeb USB API 的支援範圍並不包括所有瀏覽器。該 API 主要在 Chrome、Edge 及其他基於 Chromium 的瀏覽器中可用。因此，如果是在 Safari 中開發或使用 Web USB 功能，將無法正常運行。\n\n如需進一步了解各個瀏覽器的兼容性，請參考 [MDN 的文檔](https://developer.mozilla.org/en-US/docs/Web/API/USBDevice#browser_compatibility)。\n\n## 總結\n\n本篇文章介紹了如何使用 Web USB API 連接和管理 USB 設備，特別是針對藍牙打印機的實作範例。透過獲取 Vendor ID 和 Product ID，我們能夠有效地尋找和操作 USB 設備。希望這些範例能幫助你快速上手 Web USB API，實現更多創新的應用。\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Web Bluetooth API 的應用範例","url":"/javascript/web-bluetooth/","content":"\n{% note warning %}\n以下搭配 Xprinter XP-N160II 藍牙打印機來作範例。\n{% endnote %}\n\n## 取得設備名稱\n\n在藍牙打印機的使用中，了解設備名稱是非常重要的。打印機通常會印出一個自檢頁，其中會顯示連接名稱，這是連接設備的第一步。\n\n![Web Bluetooth Self-test page](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FWeb%20Bluetooth%20Self-test%20page.png?alt=media&token=bcd6648c-06a4-4a52-a764-0b6c634832e0)\n\n## 手動取得 ServiceUUID & CharacteristicUUID\n\n{% note warning %}\n需要搭配 <font color=\"red\">固定 UUID 的藍牙連線</font> 程式碼\n{% endnote %}\n\n獲取藍牙設備的 `ServiceUUID` 和 `CharacteristicUUID` 是進行藍牙通信的關鍵步驟。這些 UUID 用於識別設備提供的服務和特徵。\n\n在 Chrome 網址列輸入 `chrome://bluetooth-internals/#devices` 以開啟藍牙內部頁面。\n\n1. 掃描所有藍牙裝置。\n   ![Web Bluetooth start scan](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FWeb%20Bluetooth%20start%20scan.png?alt=media&token=a2997921-88ea-4e3e-bcf9-a4a6038fbbc9)\n\n2. 找到設備名稱，點擊 Inspect。\n   ![Web Bluetooth Inspect](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FWeb%20Bluetooth%20Inspect.png?alt=media&token=7dac0109-2658-4b38-ba9b-30854b27a2f8)\n\n3. 在 Service 欄下，找到 ServiceUUID。\n   ![Web Bluetooth Service](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FWeb%20Bluetooth%20Service.png?alt=media&token=1c0e28fa-25c5-4f06-b635-4e085e429b0b)\n\n4. 一層層展開，尋找標有 \"Write Without Response\" 和 \"Write\" 的項目，便可獲得 ServiceUUID 和 CharacteristicUUID。如果找不到，請繼續深入查看。\n\n   - ServiceUUID: `000018f0-0000-1000-8000-00805f9b34fb`\n   - CharacteristicUUID: `00002af1-0000-1000-8000-00805f9b34fb`\n   ![Web Bluetooth ServiceUUID & CharacteristicUUID](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FWeb%20Bluetooth%20ServiceUUID%20%26%20CharacteristicUUID.png?alt=media&token=2ca6bb96-d5fe-4b5e-9242-5a205531b290)\n\n## 固定 UUID 的藍牙連線\n\n以下的程式碼展示了如何通過指定的 UUID 來連接藍牙設備：\n\n```javascript\nconst webBleServiceUUID = '000018f0-0000-1000-8000-00805f9b34fb'; // 藍牙服務 UUID\nconst webBleCharacteristicUUID = '00002af1-0000-1000-8000-00805f9b34fb'; // 藍牙裝置特徵 ID\nlet bleServer = null;\nlet bleCharacteristic = null;\nlet bleConn = false;\n\nasync function bleConnect() {\n  try {\n    // 尋找藍牙裝置\n    const device = await navigator.bluetooth.requestDevice({\n      filters: [{ services: [webBleServiceUUID] }],\n    });\n    // 連接到 GATT 服務\n    bleServer = await device.gatt.connect();\n    // 取得藍牙服務\n    const service = await bleServer.getPrimaryService(webBleServiceUUID);\n    // 取得藍牙特徵\n    bleCharacteristic = await service.getCharacteristic(webBleCharacteristicUUID);\n    bleConn = true;\n  } catch (error) {\n    console.error('配對失敗:', error);\n  }\n}\n```\n\n## 自動取得 ServiceUUID & CharacteristicUUID 並進行藍牙連線\n\n若您希望簡化連接過程，以下程式碼可以自動尋找和連接藍牙設備：\n\n```javascript\nlet bleServer = null;\nlet bleCharacteristic = null;\nlet bleConn = false;\n\nasync bleConnect() {\n  try {\n    // 尋找藍芽裝置\n    const device = await navigator.bluetooth.requestDevice({\n      acceptAllDevices: true, // 取得所有裝置\n    });\n    // 連接到 GATT 服務\n    bleServer = await device.gatt.connect();\n    const services = await bleServer.getPrimaryServices();\n    // 取得第一個服務的 UUID\n    const servicesUUID = services[0].uuid;\n    // 獲取所有服務\n    const service = await bleServer.getPrimaryService(servicesUUID);\n    // 獲取所有特徵\n    const characteristicsAll = await service.getCharacteristics();\n    // 篩選可以寫入的特徵\n    bleCharacteristic = characteristicsAll.find(i => i.properties.write && i.properties.writeWithoutResponse);\n    bleConn = true;\n  } catch (error) {\n    console.error('配對失敗:', error);\n  }\n}\n```\n\n## 手動讓藍牙斷線\n\n當需要手動斷開藍牙連接時，可以使用以下函數：\n\n```javascript\nfunction webBleDisconnect() {\n  if (!bleConn) return;\n  bleServer.disconnect();\n  bleConn = bleServer.connected;\n}\n```\n\n此函數用於手動斷開藍牙連接。管理連接狀態對於確保系統穩定性至關重要，該函數會檢查當前是否已經連接，然後進行斷線操作。\n\n## 瀏覽器支援狀況\n\nWeb Bluetooth API 的支援範圍並不包括所有瀏覽器。該 API 主要在 Chrome、Edge 及其他基於 Chromium 的瀏覽器中可用。因此，如果是在 Safari 中開發或使用 Web Bluetooth 功能，將無法正常運行。\n\n如需進一步了解各個瀏覽器的兼容性，請參考 [MDN 的文檔](https://developer.mozilla.org/en-US/docs/Web/API/Web_Bluetooth_API#browser_compatibility)。\n\n## 總結\n\nWeb Bluetooth API 提供了一種方便的方式來與藍牙設備進行交互。透過本文中的範例，您應該能夠理解如何獲取藍牙設備的 UUID、建立連接及管理連接狀態。這為未來的應用開發打下了良好的基礎。\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Hexo 筆記好用套件：MarkdownLint","url":"/vscode/markdownLint/","content":"\n## 前言\n\n在撰寫 Hexo 筆記時，Markdown 語法可以讓文章結構清晰、美觀。然而，隨著內容的增加，保持格式的一致性與規範性可能變得困難。此時，一個好用的套件就顯得尤為重要。今天，我要介紹的就是 **MarkdownLint**，這是一款能有效檢查 Markdown 文件的優秀工具。\n\n## MarkdownLint 是什麼？\n\nMarkdownLint 是一個 Visual Studio Code 擴展，是可以協助用戶檢查 Markdown 文檔的語法和格式。它能自動識別並報告潛在的錯誤和不一致之處，使寫作過程更加流暢。\n\n## 主要特點\n\n1. **實時檢查**：MarkdownLint 在編輯 Markdown 筆記時會即時檢查語法，並在出現問題時提供提示，讓你能隨時修正錯誤，避免在發佈後才發現問題。\n\n2. **可自訂規則**：根據需求設置檢查規則。以下是自訂規則的步驟：\n\n   **文件參考**：[MarkdownLint 規則與別名](https://github.com/DavidAnson/markdownlint?tab=readme-ov-file#rules--aliases)\n\n   ### 如何自訂規則\n\n   1. **創建配置文件**：\n      在 Markdown 項目根目錄下創建一個名為 `.markdownlint.json` 的文件，以定義自訂規則。\n\n   2. **編輯配置文件**：\n      在 `.markdownlint.json` 中添加或禁用特定規則。以下是一些常見的參數設定：\n\n      ```json\n      {\n        \"default\": true,\n        \"MD013\": false, // 禁用行長度限制\n        \"MD029\": false  // 禁用列表項前空格檢查\n      }\n      ```\n\n   3. **儲存與應用**：\n      保存 `.markdownlint.json` 文件後，MarkdownLint 將自動加載這些設定，並在編輯 Markdown 文件時應用相應的規則。\n\n3. **快速安裝**：此擴展安裝簡便，並且在 Visual Studio Code 中運行流暢，無需額外配置，讓你能快速上手。\n\n## 如何安裝\n\n1. 打開 Visual Studio Code。\n2. 前往擴展市場（Extensions Marketplace）。\n3. 搜尋 \"MarkdownLint\" 或直接訪問 [MarkdownLint](https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint)。\n4. 點擊安裝即可。\n\n## 如何查看錯誤\n\n當出現問題時，MarkdownLint 會在有問題的行上顯示`黃色波浪號`，這時你可以依照錯誤提示來進行修正，統一寫作風格。\n\n![MarkdownLint error](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/VS_Code%2FMarkdownLint%20error.png?alt=media&token=693841db-27de-4242-a127-3c2586227006)\n\n## 結論\n\n對於使用 Hexo 撰寫筆記的朋友們來說，MarkdownLint 是一個不可或缺的工具。它不僅提高了寫作效率，還幫助我們保持內容的一致性與質量。無論你是新手還是資深寫手，都能從中受益。快來試試這個好用的套件，讓你的 Hexo 筆記更上一層樓吧！\n","tags":["Hexo","VSCode"],"categories":["VSCode"]},{"title":"JavaScript dataset 應用","url":"/javascript/dataset/","content":"\n## 前言\n\n在前端開發中，`data-*` 屬性可以用來存儲自訂資料，`dataset` 屬性則提供了一種簡單的方式來讀取這些資料。本文將介紹如何使用 `data-*` 屬性和 `dataset`，並提供一些示例程式碼。\n\n## data-* - 透過 dataset 讀取自訂資料\n\n使用 `data-*` 屬性可以在 HTML 元素上添加自訂資料。以下是一個示例：\n\n```html\n<ul>\n  <li class=\"listli\" data-num=\"0\" data-dog=\"3\">拉拉</li>\n</ul>\n\n<script>\nvar list = document.querySelector('.listli');\nlist.addEventListener('click', function(e) {\n  var num = e.target.dataset.num;\n  var dog = e.target.dataset.dog;\n  console.log('num:', num);\n  console.log('dog:', dog);\n}, false);\n</script>\n```\n\n在這個示例中，我們在 `<li>` 元素上添加了兩個 `data-*` 屬性：`data-num` 和 `data-dog`。當使用者點擊該元素時，我們透過 `dataset` 屬性獲取這些資料並在控制台中輸出。\n\n![get dataset example 1](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fget%20dataset%20example%201.gif?alt=media&token=511c523f-5e75-49ab-9a94-2db66e371a59)\n\n## dataset - array 運用\n\n`dataset` 還可以與陣列結合使用，動態渲染列表並獲取相應的自訂資料。以下是一個示例：\n\n```html\n<style>\n  .list {\n    padding: 30px;\n    background: #868686;\n  }\n</style>\n\n<ul class=\"list\"></ul>\n\n<script>\nvar data = [\n  { name: 'abc' },\n  { name: 'dfg' }\n];\n\nvar list = document.querySelector('.list');\n\nfunction updateList() {\n  var str = '';\n  var len = data.length;\n  for (var i = 0; len > i; i++) {\n    str += `<li data-num=\"${i}\">${data[i].name}</li>`;\n  }\n  list.innerHTML = str;\n};\n\nupdateList(); // 渲染 li\n\nlist.addEventListener('click', function(e) {\n  if (e.target.nodeName !== 'LI') { return; }\n  var num = e.target.dataset.num;\n  console.log(data[num].name);\n});\n</script>\n```\n\n在這個示例中，我們首先定義了一個包含物件的陣列。然後，透過 `updateList` 函數生成包含 `data-num` 屬性的 `<li>` 元素，並將它們添加到頁面上。當使用者點擊某個列表項時，使用 `dataset` 獲取對應的索引，進而從陣列中獲取並輸出相應的名稱。\n\n![get dataset example 2](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fget%20dataset%20example%202.gif?alt=media&token=97f67e6a-6c2c-4be9-8872-92a4da327fbe)\n\n## 總結\n\n透過使用 `data-*` 屬性和 `dataset`，開發者可以輕鬆地將自訂資料與 HTML 元素關聯起來。這種方法不僅簡化了資料存取的過程，也提高了程式碼的可讀性和可維護性。希望這篇筆記對你理解 JavaScript 的 dataset 特性有所幫助！\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"使用 sessionStorage 儲存與管理資料","url":"/javascript/sessionStorage/","content":"\n## 簡介\n\n`sessionStorage` 是一個 Web API，與 `localStorage` 相似，但它的資料存儲是臨時的，當瀏覽器的標籤頁或視窗關閉後，儲存的資料會被清空。這使得 `sessionStorage` 非常適合儲存會話相關的資料，如用戶的登入狀態或一次性表單輸入。\n\n## 基本操作\n\n### 主要方法\n\n以下是 `sessionStorage` 的基本操作方法：\n\n- **設定值**:\n\n  ```javascript\n  sessionStorage.setItem(key, value);\n  ```\n\n- **取得值**:\n\n  ```javascript\n  sessionStorage.getItem(key);\n  ```\n\n- **移除指定項目**:\n\n  ```javascript\n  sessionStorage.removeItem(key);\n  ```\n\n- **清空所有項目**:\n\n  ```javascript\n  sessionStorage.clear();\n  ```\n\n### 使用範例\n\n```javascript\nconst name = 'Alice';\nsessionStorage.setItem('myName', name);\nconsole.log(sessionStorage.getItem('myName')); // Alice\n\nsessionStorage.removeItem('myName');\nconsole.log(sessionStorage.getItem('myName')); // null\n```\n\n## 基礎範例\n\n以下是一個簡單的範例，展示如何使用 `sessionStorage` 儲存和讀取使用者的姓名：\n\n```html\n<h2>輸入你的姓名</h2>\n<input type=\"text\" class=\"textClass\">\n<button type=\"button\" class=\"btn\">送出</button>\n<button type=\"button\" class=\"callBtn\">呼叫名字</button>\n\n<script>\n  const textClass = document.querySelector('.textClass');\n  const btn = document.querySelector('.btn');\n  const callBtn = document.querySelector('.callBtn');\n\n  btn.addEventListener('click', function() {\n    // 儲存至 sessionStorage 並清空輸入框\n    sessionStorage.setItem('myName', textClass.value);\n    textClass.value = '';\n  }, false);\n\n  callBtn.addEventListener('click', function() {\n    // 從 sessionStorage 讀取值並顯示在輸入框\n    textClass.value = sessionStorage.getItem('myName');\n  }, false);\n</script>\n```\n\n![sessionStorage example](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FsessionStorage%20example.gif?alt=media&token=42e541ca-26d8-4f7e-992a-39fb8df1e712)\n\n## 從物件或陣列轉換為字串\n\n與 `localStorage` 一樣，`sessionStorage` 也只能儲存字串，因此在儲存物件或陣列時，必須使用 `JSON.stringify()` 和 `JSON.parse()` 方法。\n\n### 實作範例\n\n```javascript\n<script>\n  const data = [{ name: '小華' }];\n  const dataString = JSON.stringify(data); // 物件或陣列轉字串\n  sessionStorage.setItem('data', dataString);\n\n  const getData = sessionStorage.getItem('data');\n  const getDataArray = JSON.parse(getData); // 字串轉物件或陣列\n  console.log(getDataArray);\n</script>\n```\n\n![sessionStorage to string](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FsessionStorage%20to%20string.gif?alt=media&token=aec205c4-ea5c-4ca4-a15c-8388268ed2c1)\n\n## 注意事項\n\n- **存儲限制**: `sessionStorage` 的容量限制與 `localStorage` 類似，通常在 5MB 左右。\n- **安全性**: 與 `localStorage` 相同，`sessionStorage` 的資料以明文形式儲存，因此不適合儲存敏感資訊。\n- **作用域**: `sessionStorage` 的資料僅在當前標籤頁或視窗中有效，關閉標籤頁或視窗後資料會被清除。\n\n通過以上內容，我們可以更深入地了解 `sessionStorage` 的用法及其在網頁開發中的應用。\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"使用 localStorage 儲存與管理資料","url":"/javascript/localStorage/","content":"\n## 簡介\n\n`localStorage` 是一個 Web API，允許我們在瀏覽器中以鍵值對的形式持久化儲存資料。儲存在 `localStorage` 的資料在關閉瀏覽器後仍然保留，直到明確地刪除。這使得它非常適合用來儲存用戶偏好設定或應用狀態等資訊。\n\n## 基本操作\n\n### 主要方法\n\n以下是 `localStorage` 的基本操作方法：\n\n- **設定值**:\n\n  ```javascript\n  localStorage.setItem(key, value);\n  ```\n  \n- **取得值**:\n\n  ```javascript\n  localStorage.getItem(key);\n  ```\n\n- **移除指定項目**:\n\n  ```javascript\n  localStorage.removeItem(key);\n  ```\n\n- **清空所有項目**:\n\n  ```javascript\n  localStorage.clear();\n  ```\n\n### 使用範例\n\n```javascript\nconst name = 'Tom';\nlocalStorage.setItem('myName', name);\nconsole.log(localStorage.getItem('myName')); // Tom\n\nlocalStorage.removeItem('myName');\nconsole.log(localStorage.getItem('myName')); // null\n```\n\n## 基礎範例\n\n以下是一個簡單的範例，展示如何使用 `localStorage` 儲存和讀取使用者的姓名：\n\n```html\n<h2>輸入你的姓名</h2>\n<input type=\"text\" class=\"textClass\">\n<button type=\"button\" class=\"btn\">送出</button>\n<button type=\"button\" class=\"callBtn\">呼叫名字</button>\n\n<script>\n  const textClass = document.querySelector('.textClass');\n  const btn = document.querySelector('.btn');\n  const callBtn = document.querySelector('.callBtn');\n\n  btn.addEventListener('click', function() {\n    // 儲存至 localStorage 並清空輸入框\n    localStorage.setItem('myName', textClass.value);\n    textClass.value = '';\n  }, false);\n\n  callBtn.addEventListener('click', function() {\n    // 從 localStorage 讀取值並顯示在輸入框\n    textClass.value = localStorage.getItem('myName');\n  }, false);\n</script>\n```\n\n![localStorage example](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FlocalStorage%20example.gif?alt=media&token=0881814f-0828-46ea-9563-ae5ce778ca90)\n\n## 從物件或陣列轉換為字串\n\n由於 `localStorage` 僅能儲存字串，因此當需要儲存物件或陣列時，必須將其轉換為字串格式。這可以透過 `JSON.stringify()` 和 `JSON.parse()` 方法來實現。\n\n### 實作範例\n\n```javascript\n<script>\n  const data = [{ name: '小城' }];\n  const dataString = JSON.stringify(data); // 物件或陣列轉字串\n  localStorage.setItem('data', dataString);\n\n  const getData = localStorage.getItem('data');\n  const getDataArray = JSON.parse(getData); // 字串轉物件或陣列\n  console.log(getDataArray);\n</script>\n```\n\n![localStorage to string](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FlocalStorage%20to%20string.gif?alt=media&token=6801e003-a90a-4a15-a700-17f293a35f74)\n\n## 注意事項\n\n- **存儲限制**: 不同瀏覽器對於 `localStorage` 的容量限制不同，一般在 5MB 左右。\n- **安全性**: `localStorage` 資料以明文形式儲存，因此不適合儲存敏感資訊，如密碼或信用卡號碼。\n- **性能考量**: 在執行大量資料的讀寫操作時，`localStorage` 可能會影響頁面的性能。因此，對於頻繁操作的情況，應考慮其他存儲方案。\n\n通過以上內容，我們可以更深入地了解 `localStorage` 的用法及其在網頁開發中的應用。\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Cordova 移除 Android 12 APP 啟動動畫","url":"/cordova/remove-android-12-splash-screen/","content":"\n## 前言\n\n在 Cordova 開發中，若要移除 Android 12 的 APP 啟動動畫，可以在以下檔案中進行設置：\n\n### 步驟\n\n1. 打開 `\\platforms\\android\\app\\src\\main\\res\\values\\themes.xml`。\n2. 在適當的位置加入以下代碼：\n\n   ```xml\n   <item name=\"android:windowIsTranslucent\">true</item>\n   ```\n\n這樣的設定會讓啟動畫面變得透明，可能會導致 APP 啟動後出現延遲，因為畫面會等到 APP 完全啟動後才顯示。\n\n![cordova setting themes.xml](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20setting%20themes.png?alt=media&token=a00bcdce-6b8f-43d2-91ef-c6d27aab07d1)\n\n## AutoHideSplashScreen 設定\n\n根據[官方文件](https://cordova.apache.org/docs/en/dev/core/features/splashscreen/index.html#autohidesplashscreen)，`AutoHideSplashScreen` 預設為 `true`，但在實際測試中，這個設定無法完全隱藏 splash screen。以下是一些相關的程式碼和說明。\n\n### 程式碼示例\n\n- 在 `config.xml` 中，你可以確認是否有以下設定：\n\n   ```xml\n   <preference name=\"AutoHideSplashScreen\" value=\"true\" />\n   ```\n\n- 在 Vue 的 `public/index.html` 中，確保加入以下內容：\n\n   ```html\n   <div id=\"app\"></div>\n   <% if (process.env.NODE_ENV==='production') { %>\n     <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self' data: gap: https://ssl.gstatic.com 'unsafe-eval'; style-src 'self' 'unsafe-inline'; media-src *; img-src 'self' data: content:;\">\n     <script src=\"cordova.js\" defer></script>\n   <% } %>\n   <script>\n     document.addEventListener('DOMContentLoaded', () => {\n       console.log('DOMContentLoaded');\n       document.addEventListener(\"deviceready\", onDeviceReady, false);\n     });\n     function onDeviceReady() {\n       console.log('onDeviceReady');\n     }\n   </script>\n   ```\n\n### 整體渲染過程\n\n整體的渲染過程如下：\n\n1. 打開 APP\n2. 啟動 splash screen\n3. 載入 `index.html`\n\n![cordova SplashScreen rendering process](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20SplashScreen%20rendering%20process.gif?alt=media&token=e4876361-b412-46b9-a0a9-a11a9d0a7689)\n\n雖然 `AutoHideSplashScreen` 功能似乎無法完全隱藏 splash screen，但某些情況下仍可能需要手動控制，例如在完成 API 調用後再隱藏。\n\n### 設定為 false 的情況\n\n如果將 `AutoHideSplashScreen` 設定為 `false`，則需要手動調用 API 來隱藏 splash screen：\n\n```javascript\nfunction onDeviceReady() {\n  console.log('onDeviceReady 註解 hide');\n}\n```\n\n在這種情況下，即使 `index.html` 已經載入完成，splash screen 仍不會自動關閉。\n\n![cordova SplashScreen won't auto-close](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20SplashScreen%20won't%20auto-close.gif?alt=media&token=8c4e5308-5628-48ba-b136-2a73a28ee0f4)\n\n### 使用 API 來關閉 splash screen\n\n你可以通過以下方式使用 API 來隱藏 splash screen：\n\n```javascript\nfunction onDeviceReady() {\n  console.log('onDeviceReady');\n\n  // 進行 API 調用...\n\n  // Android 關閉\n  navigator.splashscreen.hide();\n\n  // 對於 iOS，官方建議的方式是設置延遲關閉\n  setTimeout(() => {\n    navigator.splashscreen.hide();\n  }, 2000);\n}\n```\n","tags":["Cordova"],"categories":["cordova"]},{"title":"整合 Vue 到 Cordova 專案中","url":"/cordova/integrate-vue-cordova/","content":"\n## 官方文檔\n\n如需更多資訊，請參閱 [cordova](https://cordova.apache.org/)。\n\n## 安裝套件\n\n```bash\nnpm install -g cordova\n```\n\n## 建立專案資料夾\n\n首先，我們需要創建一個新的 Cordova 專案。使用以下命令可以完成此操作：\n\n```bash\ncordova create hello com.example.hello HelloWorld\n```\n\n- `hello`：資料夾名稱\n- `com.example.hello`：XML ID\n- `HelloWorld`：應用名稱\n\n![cordova folder structure](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20folder%20structure.png?alt=media&token=097f4862-bc4d-47b7-b330-66f6913caa13)\n\n## 新增平台 (iOS & Android)\n\n接下來，進入專案資料夾並新增 iOS 和 Android 平台：\n\n```bash\ncd hello\ncordova platform add ios\ncordova platform add android\n```\n\n![cordova platform](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20platform.png?alt=media&token=f52d312f-1502-4764-b327-6c3d7e8d3bb5)\n\n這將會在專案中新增許多資料夾和檔案，例如 `node_modules` 等等。\n\n![cordova folder structure platform](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20folder%20structure%20platform.png?alt=media&token=0a702016-5e53-4269-92e1-52f526d684e8)\n\n## 查詢目前的平台清單\n\n要檢查目前已安裝的平台，使用以下命令：\n\n```bash\ncordova platform ls\n```\n\n目前只安裝了 Android 平台。\n\n![cordova platform ls](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20platform%20ls.png?alt=media&token=8b14dab0-eabd-42c0-8bd2-95fc89a06210)\n\n## 移除某個平台\n\n如果需要移除某個平台（例如 Android），可以使用以下命令：\n\n```bash\ncordova platform rm android\n```\n\n![cordova platform rm android](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20platform%20rm%20android.png?alt=media&token=497b0045-6051-4286-bf8b-cef322a0392d)\n\n## 建立 APP\n\n使用以下命令來建立應用程式：\n\n- 建立所有已安裝平台的 APP：\n\n  ```bash\n  cordova build\n  ```\n\n- 建立特定平台的 APP（例如 Android）：\n\n  目前您手邊沒有 Mac，因此無法測試 iOS 平台的構建，如果你有 Mac，也可以順便安裝 `cordova build ios`。\n\n  您可以使用以下命令僅建置 Android 應用：\n\n  ```bash\n  cordova build android\n  ```\n\n這將生成 Android 的 APK 檔案，您可以將其安裝到任何 Android 設備或模擬器中進行測試。\n\n![cordova apk path](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20apk%20path.png?alt=media&token=215d4a3c-0bd2-45b0-ac23-3fd421af366b)\n\n## 安裝測試 APP\n\n將生成的 `app-debug.apk` 檔案放入任何手機模擬器中即可進行測試。\n\n![cordova apk](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20apk.png?alt=media&token=9846a015-2bb5-43f7-80ac-544a09ec6abd)\n\n這是 APP 安裝完成後開啟的畫面。\n\n![cordova startup screen](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20startup%20screen.png?alt=media&token=1cb5435f-a96e-4878-ae15-243c368e36dc)\n\n## 加入 Vue\n\n在專案的根目錄下，創建一個 Vue 專案。請根據需求選擇適合的 Vue 版本（目前使用的是 Vue 3）。\n\n![create vue](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcreate%20vue.png?alt=media&token=0ec78cd3-2fd1-4d1f-b677-1ab21b09c9d4)\n\n選擇完成後，讓其執行一下。\n\n![create vue process](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcreate%20vue%20process.png?alt=media&token=dabfe91d-5346-42cd-9c2d-0a0402132d37)\n\n執行完成後，會多一個 Vue 的資料夾。\n\n![cordova add vue](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20add%20vue.png?alt=media&token=d85c15cb-b9f6-47cd-8a0f-e3585964b5cc)\n\n## 修改 vue.config.js\n\n在 Vue 專案中，找到並修改 `vue.config.js` 檔案：\n\n```javascript\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  publicPath: './', // 一定要加 .\n  outputDir: '../www', // 輸出位置\n  productionSourceMap: false, // 不產生 map 文件\n})\n```\n\n![cordova settings vue config](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20settings%20vue%20config.png?alt=media&token=955fa978-3033-4a5b-8592-28d5a8d8538d)\n\n## 建置 Vue\n\n使用以下命令來建置 Vue 專案：\n\n```bash\nnpm run build\n```\n\n這樣會在外層的 `www` 資料夾下生成 HTML、CSS、JS 等檔案。\n\n![cordova build vue](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20build%20vue.png?alt=media&token=6f60fbb2-d481-4529-941e-93086d63aa86)\n\n## 將 Vue 封裝成 APP\n\n再次執行 Cordova 建置命令：\n\n```bash\ncordova build\n```\n\n![cordova build APP](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20build%20APP.png?alt=media&token=4bafa8d3-69fc-43f2-91f6-48269fa6bf6f)\n\n將應用程式放入模擬器中進行測試。\n\n![cordova install to emulator](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20install%20to%20emulator.png?alt=media&token=3f073a90-adcc-451d-ac8e-1268fba2a1a6)\n\n當你打開它時，恭喜你，專案成功完成！\n\n![cordova to emulator Installation successful](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2Fcordova%20to%20emulator%20Installation%20successful.png?alt=media&token=cfe27364-cd07-4654-a867-ac1d4af7c304)\n","tags":["Cordova","Vue"],"categories":["cordova"]},{"title":"axios 套件筆記","url":"/javascript/axios/","content":"\n## 官方文檔\n\n如需更多資訊，請參閱 [Axios 官方 GitHub 頁面](https://github.com/axios/axios#browser-support)。\n\n## 基本用法\n\n### GET 請求\n\n使用 `axios.get()` 方法來發送 GET 請求。\n\n```javascript\naxios.get('https://randomuser.me/api/')\n  .then(res => {\n    console.log('success:', res);\n  })\n  .catch(err => {\n    console.log('error:', err);\n  });\n```\n\n### POST 請求\n\n使用 `axios.post()` 方法來發送 POST 請求，並傳送資料。\n\n```javascript\nconst data = {\n  name: 'John Doe',\n  email: 'john.doe@example.com'\n};\n\naxios.post('https://randomuser.me/api/', data)\n  .then(res => {\n    console.log('success:', res);\n  })\n  .catch(err => {\n    console.log('error:', err);\n  });\n```\n\n### PATCH 請求\n\n使用 `axios.patch()` 方法來更新資源。\n\n```javascript\nconst updateData = {\n  email: 'john.updated@example.com'\n};\n\naxios.patch('https://randomuser.me/api/1', updateData)\n  .then(res => {\n    console.log('success:', res);\n  })\n  .catch(err => {\n    console.log('error:', err);\n  });\n```\n\n## 錯誤處理\n\nAxios 提供了 `.catch()` 方法來處理請求中的錯誤。這使得錯誤管理變得更加方便和直觀。\n\n```javascript\naxios.get('https://randomuser.me/api/')\n  .then(res => {\n    console.log('success:', res);\n  })\n  .catch(err => {\n    console.error('error:', err);\n  });\n```\n\n## 小結\n\nAxios 是一個非常強大的工具，適合用於進行各種 HTTP 請求。它的 Promise-based 結構使得異步操作變得更加簡單。了解如何使用它可以幫助你更有效地進行資料交換和網絡請求。\n","tags":["JavaScript","axios"],"categories":["JavaScript"]},{"title":"認識 AJAX，了解同步與非同步與 HTTP 狀態碼","url":"/javascript/ajax/","content":"\n## 使用流程\n\n1. 建立 AJAX 物件\n2. 發送請求到伺服器獲取資料\n3. 伺服器回傳資料到瀏覽器\n4. 獲取資料並進行渲染或加工處理\n\n### 1. 建立 XMLHttpRequest 物件\n\n使用 `XMLHttpRequest` 物件來進行 AJAX 請求，並在 console 中查看 `xhr` 變數的內容。\n\n```javascript\nvar xhr = new XMLHttpRequest();\n```\n\n![XHR Object](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FAJAX%20XHR%20Object.gif?alt=media&token=0ec8e3e1-4510-4dc2-8c73-101d48031c7b)\n\n> **重點**：`readyState` 的數字代表不同的狀態\n\n| readyState 數字 | 代表涵義 |\n|----------------|----------|\n| 0              | XMLHttpRequest 物件已建立，但尚未連結 |\n| 1              | 已調用 `open()`，但尚未發送請求 |\n| 2              | 偵測到已調用 `send()` |\n| 3              | 正在加載中，可能資料量較大 |\n| 4              | 資料已完全獲取 |\n\n### 2. 使用 `open()` 連結資料\n\n`open()` 方法用來設定請求的格式、網址以及同步或非同步。\n\n```javascript\n// xhr.open('格式', '讀取的網址', '同步與非同步')\nxhr.open('GET', 'https://hexschool.github.io/ajaxHomework/data.json', true);\n```\n\n| 格式 | 代表涵義 |\n|------|----------|\n| GET  | 讀取資料 |\n| POST | 發送資料到伺服器 |\n\n| 同步與非同步 | 代表涵義 |\n|--------------|----------|\n| true         | 非同步，不會等待回應，程式碼會繼續執行 |\n| false        | 同步，會等待回應後再繼續執行 |\n\n由於調用了 `open()`，此時 `readyState` 為 1。\n\n![Open State](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FAJAX%20Open%20State.gif?alt=media&token=1faf7f5b-4a55-499d-a37a-96caca3958eb)\n\n### 3. 使用 `send()` 傳送資料\n\n我們目前只需讀取資料，因此可傳送 `null`。\n\n```javascript\nxhr.send(null);\n```\n\n- 使用 `send()` 後，`readyState` 會從 2（偵測到 `send()`）變為 3（加載中），最終變為 4（資料獲取完成）。\n\n![Data Retrieved](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FAJAX%20Data%20Retrieved.gif?alt=media&token=735496a2-e902-4003-b3ef-57c5143fde12)\n\n### 4. 獲取資料\n\n- **非同步請求**\n  \n當使用非同步時，程式碼執行速度很快，可能在資料回傳之前就打印出 `console`。\n\n```javascript\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://hexschool.github.io/ajaxHomework/data.json', true);\nxhr.send(null);\nconsole.log('xhr資料：', xhr.responseText); // 可能會顯示空值\n```\n\n可以使用 `onload` 方法來獲取資料：\n\n```javascript\nxhr.onload = function() {\n  console.log('xhr資料：', xhr.responseText);\n};\n```\n\n再用 `JSON.parse` 將字串轉成物件並顯示在畫面上：\n\n```javascript\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://hexschool.github.io/ajaxHomework/data.json', true);\nxhr.send(null);\nxhr.onload = function() {\n  var str = JSON.parse(xhr.responseText);\n  document.querySelector('.text').textContent = str[0].name;\n};\n```\n\n- **同步請求**\n\n使用同步請求可以先獲取資料，但資料量過大會影響使用者體驗。\n\n```javascript\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://hexschool.github.io/ajaxHomework/data.json', false);\nxhr.send(null);\nconsole.log('xhr資料：', xhr.responseText);\n```\n\n使用 `JSON.parse` 來轉換並顯示資料：\n\n```javascript\nvar str = JSON.parse(xhr.responseText);\ndocument.querySelector('.text1').textContent = str[0].name;\n```\n\n## HTTP 狀態碼\n\n| 狀態碼 | 代表涵義 |\n|--------|----------|\n| 200    | 成功 (OK) |\n| 3XX    | 重新導向 (Redirection) |\n| 404    | 找不到檔案或目錄 |\n\n## Cross-Origin Resource Sharing (CORS)\n\nCORS 是一種機制，使用額外的 HTTP 標頭使得瀏覽器能夠獲取來自不同來源的資源。當請求的資源來自不同的網域、協定或通訊埠時，會建立一個跨來源 HTTP 請求。\n\n因為安全性考量，跨來源請求受到限制。`XMLHttpRequest` 和 `Fetch` 都遵循同源政策（Same-Origin Policy），除非使用 CORS 標頭，否則只能請求與應用程式相同網域的資源。\n\n簡而言之，在同一網域下 API 可以自由使用，但在不同網域下必須確認對方的後端是否開啟 CORS，否則會出現錯誤訊息。\n\n![CORS Error](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FAJAX%20CORS%20Error.png?alt=media&token=fc66ed6c-a530-46c9-9baa-62a58df46fc2)\n\n測試 CORS 網址：[cors-tester](https://myxml.in/cors-tester.html)\n\n## AJAX 兩種傳送方式\n\n1. 傳統傳送方式\n2. JSON 傳送方式\n\n這兩種方式的程式碼差異在於 `setRequestHeader` 的 `Content-Type` 和 `send` 傳送的值。\n\n### AJAX 傳統傳送方式\n\n```html\n<form action=\"index.html\">\n  帳號：<input class=\"email\" type=\"text\" name=\"email\" id=\"\">\n  <br>\n  密碼：<input class=\"password\" type=\"password\" name=\"password\" id=\"\">\n  <br>\n  <input class=\"send\" type=\"submit\" value=\"send\">\n</form>\n\n<script>\nvar xhr = new XMLHttpRequest();\nvar send = document.querySelector('.send');\nvar text = document.querySelector('.text');\nsend.addEventListener('click', function(e) {\n  e.preventDefault();\n  var emailVal = document.querySelector('.email').value;\n  var passwordVal = document.querySelector('.password').value;\n  xhr.open('POST', 'https://hexschool-tutorial.herokuapp.com/api/signup', true);\n  xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n  xhr.send(`email=${emailVal}&password=${passwordVal}`);\n  xhr.onload = function() {\n    var msg = JSON.parse(xhr.response);\n    text.textContent = msg.message;\n  };\n});\n</script>\n```\n\n### AJAX JSON 傳送方式\n\n```html\n<form action=\"index.html\">\n  帳號：<input class=\"email\" type=\"text\" name=\"email\" id=\"\">\n  <br>\n  密碼：<input class=\"password\" type=\"password\" name=\"password\" id=\"\">\n  <br>\n  <input class=\"send\" type=\"submit\" value=\"send\">\n</form>\n\n<script>\nvar xhr = new XMLHttpRequest();\nvar send = document.querySelector('.send');\nvar text = document.querySelector('.text');\nsend.addEventListener('click', function(e) {\n  e.preventDefault();\n  var data = {\n    email: document.querySelector('.email').value,\n    password: document.querySelector('.password').value,\n  };\n  xhr.open('POST', 'https://hexschool-tutorial.herokuapp.com/api/signup', true);\n  xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n  xhr.send(JSON.stringify(data));\n  xhr.onload = function() {\n    var msg = JSON.parse(xhr.response);\n    text.textContent = msg.message;\n  };\n});\n</script>\n```\n\n不論是傳統還是 JSON 方式，傳送結果都會一致，具體使用哪一種需依據後端工程師的需求。\n\n![AJAX Result](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FAJAX%20Result.gif?alt=media&token=75ebbcc1-9f5d-44d3-a4b7-65bb14bc305a)\n","tags":["JavaScript","AJAX"],"categories":["JavaScript"]},{"title":"Hexo NexT 開啟 Gitalk 留言版","url":"/hexo/next-gitalk/","content":"\n## 前言\n\n決定使用 Gitalk 來當我部落格的留言板後，中間一度卡關等等會再提到卡關的細節，差點想放棄用別的留言板，希望來看的人安裝與使用都能夠不卡關。\n\n## 註冊 OAuth Apps\n\n### 登入你的 GitHub 點擊頭像\n\n![GitHub header](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitHub%20header.png?alt=media&token=bc620665-dc2e-44ef-abcb-4409262ca333)\n\n### 點選 Settings\n\n![GitHub sidebar](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitHub%20sidebar.png?alt=media&token=fea9d1b0-bc79-4366-86a1-ab947bbc4851)\n\n### 點選 Developer settings\n\n頁面要往下拉才會看到 `Developer settings` 通常在左側最下面\n![GitHub Developer settings](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitHub%20Developer%20settings.png?alt=media&token=24a0be35-f676-4a64-a74f-9da27e71ac9b)\n\n### 新增 OAuth App\n\n點選左側的 `OAuth Apps` -> 在點 `New OAuth App`\n![GitHub New OAuth App](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitHub%20New%20OAuth%20App.png?alt=media&token=fef39b81-3328-4881-9bd7-ea1ced5b939d)\n\n### 填寫 OAuth App 資料\n\n1. **Application name**：應用程式的名稱，例如：`XXX 部落格`\n\n2. **Homepage URL**：應用程式主頁的完整 URL。使用者點擊連結後會被帶到這個地址，通常是應用程式的官網或項目頁面，例如：`https://asz8621.github.io/`\n\n3. **Application description**：應用程式的描述，這是顯示給所有使用你應用程式的使用者的文字，幫助使用者了解應用程式的功能和用途，例如：`部落格 OAuth`\n\n4. **Authorization callback URL**：應用程式的回調 URL。在使用者授權後，GitHub 會將使用者重新導向到這個 URL。確保此 URL 與應用程式的設定相匹配，以避免授權錯誤，例如：`https://asz8621.github.io/`\n\n5. **Enable Device Flow**：允許此 OAuth 應用程式透過裝置流（Device Flow）來授權使用者。設備流通常用於沒有瀏覽器或輸入設備的場景，例如智慧電視或物聯網設備。啟用後，使用者可以透過裝置取得授權代碼並在其他裝置上輸入，以完成登入。\n\n![GitHub Register a new OAuth application](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitHub%20Register%20a%20new%20OAuth%20application.png?alt=media&token=dfd87566-299a-41fe-b627-2f4aeea17ae5)\n\n### 取得 Client Secret\n\n註冊完 OAuth App 會跳到此畫面，點選 `Generate a new client secret` 來取得 Client Secret\n![GitHub get  secret](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitHub%20get%20%20secret.png?alt=media&token=8e6db2fd-59a2-47e4-8195-d1c1bf480598)\n\n跳出以下畫面代表取得完成，請先複製你的 `Client Secret`，不然重新整理後你就無法複製 `Client Secret`，再來複製你的 `Client ID` 等等設定也會用到\n![GitHub OAuth secret value](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitHub%20OAuth%20secret%20value.png?alt=media&token=0f92d47b-b49a-41ab-b0b8-3b5640c8869b)\n\n## next/_config.yml 設定\n\n這邊的設定我原本想放在 [Hexo NexT _config.yml 設定](/hexo/next-config-configuration) 這篇裡面，但試想一想還是算了，拉一篇新的來寫比較詳細，以下是我的設定：\n\n```yaml\ngitalk:\n  enable: true\n  github_id: asz8621 # GitHub repo owner\n  repo: asz8621.github.io # Repository name to store issues\n  client_id: 貼上剛剛複製的_Client_ID # GitHub Application Client ID\n  client_secret: 貼上剛剛複製的_Client_Secret # GitHub Application Client Secret\n  admin_user: asz8621 # GitHub repo owner and collaborators, only these guys can initialize gitHub issues\n  distraction_free_mode: true # Facebook-like distraction free mode\n  # When the official proxy is not available, you can change it to your own proxy address\n  proxy: https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token # This is official proxy address\n  # Gitalk's display language depends on user's browser or system environment\n  # If you want everyone visiting your site to see a uniform language, you can set a force language value\n  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW\n  labels: Gitalk\n  language: zh-TW\n```\n\n1. **enable**：啟用或禁用 Gitalk 評論系統。如果設置為 `true`，則會在頁面上顯示評論。\n\n2. **github_id**：GitHub 倉庫的擁有者用戶名，用於指定存儲評論的倉庫。\n\n3. **repo**：用於存儲評論的 GitHub 倉庫名稱。評論將以 issue 的形式存儲在這個倉庫中。\n\n4. **client_id**：GitHub OAuth 的 Client ID。\n\n5. **client_secret**：GitHub OAuth 的 Client Secret。注意，這個請勿公開，如果遺失再去申請一個。\n\n6. **admin_user**：具有初始化 GitHub issues 權限的用戶列表，僅這些用戶可以創建和管理評論。\n\n7. **distraction_free_mode**：啟用“專注模式”，在這種模式下，評論框會減少其他干擾，更加簡潔。\n\n8. **proxy**：當官方代理不可用時，可以設置自定義的代理地址。代理用於解決跨域請求的問題。\n\n9. **labels**：為 GitHub issue 添加標籤，便於分類和管理評論。\n\n10. **language**：設置 Gitalk 的顯示語言。如果希望所有訪問者看到統一的語言，可以在這裡指定（如 `zh-TW` 表示繁體中文）。\n\n到這邊就差不多設定完成了，再來就是將部落格重新整理後隨便選一篇文章拉到最下面去看一下有沒有設定成功，以下是成功的畫面：\n\n![Gitalk set up successfully](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitalk%20set%20up%20successfully.png?alt=media&token=390328d8-971e-4ff1-ab5d-2d2bdeaad901)\n\n## 頁面選擇是否開啟 Gitalk\n\n當你完成設置後，可能會發現不僅文章底部會顯示 Gitalk，其他頁面也會出現。若要隱藏這些頁面的評論功能，只需在 `hexo/source` 下的 `about`、`categories` 和 `tags` 資料夾中，將設定改為 `comments: false` 即可。\n\n![Gitalk hidden settings](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitalk%20hidden%20settings.png?alt=media&token=e5f878cd-0dfe-41f1-ae17-055a3dbf34a1)\n\n---\n\n## 再來就是說說我卡關的部分，大概會出現兩種狀況，先來說第一種狀況\n\n### 狀況一：Gitalk 出現 Error Not Found\n\n![Gitalk Error Not Found](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitalk%20Error%20Not%20Found..png?alt=media&token=f000db7a-07c5-454c-be52-3cbe5fc2418d)\n\n1. 請先確認 `next/_config.yml` 與 OAuth App 資料 是否寫正確\n2. 確保你的 Blog 專案是公開的。\n\n### 狀況二：未找到相關的 issues 進行評論\n\n![Gitalk No related issues found](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitalk%20%20No%20related%20issues%20found.png?alt=media&token=fe92c279-5d2c-420f-a962-eb7f78b55e99)\n\n這狀況看似簡單登入好像就完成了，但結果卻不是你所想的那樣，因為只要你登入會出現以下畫面\n\nBe careful!\nThe redirect_uri is not associated with this application.\nThe application might be misconfigured or could be trying to redirect you to a website you weren't expecting.\n\n![Gitalk Be careful](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitalk%20Be%20careful.png?alt=media&token=0c301d5c-fc76-455f-907b-883fd485d01d)\n\n這時候你看一下網址的 `redirect_uri`，你會發現怎麼不是 `XXXXX.github.io`，因為我有買網址並且用 Cloudflare 管理我的網址，所以會轉到我買的網址上 `www.nielsen.tw` 導致出現 Be careful! 的錯誤畫面，這時候只要將它改成 `XXXXX.github.io` 就可以使用 GitHub 登入了，登入後就可以正常使用 Gitalk\n\n```yaml\n# 範例網址\nhttps://github.com/login/oauth/authorize?client_id=XXXXXXXXXXXXXXX&redirect_uri=https%3A%2F%2Fwww.nielsen.tw%2Fjavascript%2Farray-practical-uses%2F&scope=public_repo\n```\n\n希望這篇筆記能幫助各位順利完成 Gitalk 的安裝！\n","tags":["Hexo","Gitalk","GitHub"],"categories":["Hexo"]},{"title":"JavaScript 物件實戰用法","url":"/javascript/object-practical-uses/","content":"\n## 物件找相對應的值\n\n```javascript\nconst betItems = {\n  bank: {\n    abbr: \"B\",\n    detail: 0,\n    id: 2,\n    odds: 1,\n    switch: true,\n    win: false,\n  },\n  big: {\n    abbr: \"BG\",\n    detail: 500,\n    id: 2,\n    odds: 1,\n    switch: true,\n    win: false,\n  }\n};\n\nconst filteredItems = Object.keys(betItems).reduce((acc, val) => \n  (betItems[val]['detail'] > 0 ? acc : {\n    ...acc,\n    [val]: betItems[val]\n  }), \n{});\n\nconsole.log(filteredItems);\n```\n\n## 物件排序\n\n首先，使用 `Object.entries()` 方法將物件轉換成二維陣列。接著，使用 `Array.sort()` 方法依據第二個元素進行排序，最後透過 `Object.fromEntries()` 方法將排序後的二維陣列轉換回物件形式。\n\n```javascript\nconst obj = {\n  banana: 2,\n  apple: 4,\n  pear: 1,\n};\n\nconst obj2 = {\n  banana: {\n    key: 2,\n  },\n  apple: {\n    key: 4,\n  },\n  pear: {\n    key: 1,\n  }\n};\n\n// 將物件轉換成二維陣列\nconst arr = Object.entries(obj); // [ [\"banana\", 2], [\"apple\", 4], [\"pear\", 1] ]\nconst arr2 = Object.entries(obj2);\n\n// 依照第二個元素（數字）進行排序\narr.sort((a, b) => a[1] - b[1]); // [ [\"pear\", 1], [\"banana\", 2], [\"apple\", 4] ]\narr2.sort((a, b) => a[1].key - b[1].key);\n\n// 將排序後的二維陣列轉換回物件形式\nconst sortedObj = Object.fromEntries(arr); // { pear: 1, banana: 2, apple: 4 }\nconst sortedObj2 = Object.fromEntries(arr2);\n\nconsole.log(sortedObj);\nconsole.log(sortedObj2);\n```\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Hexo NexT 標籤和按鈕","url":"/hexo/next-tags-and-buttons/","content":"\n## 標籤用法\n\n在 Hexo 中，你可以使用各種標籤和樣式來提升文章的可讀性和美觀性。以下是幾種常見的用法，包括 `note`、`label`、`button` 和 `tabs`。\n\n`note`、`label` 顏色樣式可選擇 `default`、`primary`、`success`、`info`、`warning` 和 `danger`。\n\n### Note\n\n使用 `note` 樣式可以添加提示或註釋：\n\n#### HTML 方法\n\n```html\n<div class=\"note info\">我是 HTML Note</div>\n```\n\n#### Markdown 方式\n\n```markdown\n{% note info %}\n我是 Markdown Note\n{% endnote %}\n```\n\n#### 示例\n\n<div class=\"note info\">我是 HTML Note</div>\n\n{% note info %}\n我是 Markdown Note\n{% endnote %}\n\n如果不需要圖示，可以加上 `no-icon`：\n\n```markdown\n<div class=\"note info no-icon\">我是 HTML Note no-icon</div>\n\n{% note info no-icon %}\n我是 標籤 Note\n{% endnote %}\n```\n\n<div class=\"note info no-icon\">我是 HTML Note no-icon</div>\n\n{% note info no-icon %}\n我是 Markdown Note no-icon\n{% endnote %}\n\n### Label\n\n標籤可以用來標識內容的類別或類型，以下是示例：\n\n#### HTML 方式\n\n```html\n<span class=\"label primary\">HTML 標籤</span>\n```\n\n#### Markdown 方式\n\n```markdown\n{% label info @markdown 標籤 %}\n```\n\n#### 示例\n\n<span class=\"label primary\">主要標籤</span>\n\n{% label info @markdown 標籤 %}\n\n### Tabs\n\n#### 示例\n\n```markdown\n{% tabs Tabs, 2 %}\n<!-- tab -->\n我是 Tabs 1\n<!-- endtab -->\n<!-- tab -->\n我是 Tabs 2\n<!-- endtab -->\n<!-- tab -->\n我是 Tabs 3\n<!-- endtab -->\n{% endtabs %}\n```\n\n{% tabs Tabs, 2 %}\n<!-- tab -->\n我是 Tabs 1\n<!-- endtab -->\n<!-- tab -->\n我是 Tabs 2\n<!-- endtab -->\n<!-- tab -->\n我是 Tabs 3\n<!-- endtab -->\n{% endtabs %}\n\n#### 定義 Tabs 名稱\n\n```markdown\n{% tabs 选项卡 2 %}\n<!-- tab 新聞 -->\n新聞文字\n<!-- endtab -->\n<!-- tab 運動 -->\n運動文字\n<!-- endtab -->\n<!-- tab 購物 -->\n購物文字\n<!-- endtab -->\n{% endtabs %}\n```\n\n{% tabs 选项卡 1 %}\n<!-- tab 新聞 -->\n新聞文字\n<!-- endtab -->\n<!-- tab 運動 -->\n運動文字\n<!-- endtab -->\n<!-- tab 購物 -->\n購物文字\n<!-- endtab -->\n{% endtabs %}\n\n#### 加入 icon\n\n```markdown\n{% tabs google info 2 %}\n<!-- tab 我的帳號@fab fa-google -->\nfab fa-google\n<!-- endtab -->\n<!-- tab 我的遊戲@fab fa-google-play -->\nfab fa-google-play\n<!-- endtab -->\n<!-- tab 我的雲端@fab fa-google-drive\" -->\nfab fa-google-drive\n<!-- endtab -->\n{% endtabs %}\n```\n\n{% tabs google info 2 %}\n<!-- tab 我的帳號@fab fa-google -->\nfab fa-google\n<!-- endtab -->\n<!-- tab 我的遊戲@fab fa-google-play -->\nfab fa-google-play\n<!-- endtab -->\n<!-- tab 我的雲端@fab fa-google-drive\" -->\nfab fa-google-drive\n<!-- endtab -->\n{% endtabs %}\n\n### Button\n\n按鈕可以用來添加互動性，方便用戶操作或導航。以下是示例：\n\n#### HTML 方式\n\n```html\n<a class=\"btn primary\" href=\"https://example.com\">HTML a</a>\n<button type=\"button\" >HTML Btn</button>\n```\n\n#### Markdown 方式\n\n```markdown\n{% button /about/, about, fas fa-info-circle, 關於我 %}\n{% button https://www.google.com/, 前往 Google, fab fa-google, 搜索引擎 %}\n```\n\n#### 示例\n\n<a class=\"btn primary\" href=\"https://example.com\">HTML a</a>\n\n<button type=\"button\" >HTML Btn</button>\n\n{% button /about/, about, fas fa-info-circle mr-1, 關於我 %}\n\n{% button https://www.google.com/, 前往 Google, fab fa-google, 搜索引擎 %}\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"JavaScript 物件使用方法","url":"/javascript/object-methods/","content":"\n## 物件讀取方式\n\n```javascript\nlet home = {\n    dogs: 10,\n    people: 5,\n    '789': 3\n};\n\nconsole.log(home.dogs); // 10\n// console.log(home.789); // 會出錯\n// 如果物件的屬性是數字，需使用以下方式讀取\nconsole.log(home['789']); // 3\n```\n\n---\n\n## 物件新增方式\n\n```javascript\nlet home = {\n    dogs: 10,\n    people: 5,\n};\n\nhome.cat = 10;\nconsole.log(home); // {dogs: 10, people: 5, cat: 10}\n```\n\n## 物件修改方式\n\n```javascript\nlet home = {\n    dogs: 10,\n    people: 5,\n};\n\nhome.dogs = 5;\nhome.people = 24;\nconsole.log(home); // {dogs: 5, people: 24}\n```\n\n---\n\n## 刪除物件資料\n\n```javascript\nlet home = {\n    dogs: 10,\n    people: 5,\n    cat: 3\n};\n\ndelete home.cat;\nconsole.log(home); // {dogs: 10, people: 5}\n```\n\n---\n\n## 使用 `forEach()` 遍歷物件\n\n### 使用 `Object.keys()`\n\n```javascript\nconst obj = {\n    name: 'Jean-Luc Picard',\n    rank: 'Captain'\n};\n\nconsole.log(Object.keys(obj)); // ['name', 'rank']\n\nObject.keys(obj).forEach(key => {\n    console.log(key, obj[key]);\n    // name Jean-Luc Picard\n    // rank Captain\n});\n```\n\n### 使用 `Object.values()`\n\n```javascript\nconst obj = {\n    name: 'Jean-Luc Picard',\n    rank: 'Captain'\n};\n\nconsole.log(Object.values(obj)); // ['Jean-Luc Picard', 'Captain']\n\nObject.values(obj).forEach(val => {\n    console.log(val);\n    // Jean-Luc Picard\n    // Captain\n});\n```\n\n### 使用 `Object.entries()`\n\n```javascript\nconst obj = {\n    name: 'Jean-Luc Picard',\n    rank: 'Captain'\n};\n\nconsole.log(Object.entries(obj)); \n// [\n//   [\"name\", \"Jean-Luc Picard\"],\n//   [\"rank\", \"Captain\"]\n// ]\n\nObject.entries(obj).forEach(([key, value]) => {\n    console.log(key, value);\n    // name Jean-Luc Picard\n    // rank Captain\n});\n```\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript 會改變原始陣列語法","url":"/javascript/changes-original-array-functions/","content":"\n## push() - 將資料添加至陣列末尾\n\n<strong>`push()`</strong> 方法可將一或多個值添加至陣列的末尾，並自動更新陣列的長度。\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\na.push(9, 10);\nconsole.log(a); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n---\n\n## pop() - 刪除陣列最後一個元素\n\n<strong>`pop()`</strong> 方法用來移除並返回陣列的最後一個元素。\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nlet b = a.pop();\nconsole.log(a); // [1, 2, 3, 4, 5, 6, 7]\nconsole.log(b); // 8\n```\n\n---\n\n## shift() - 刪除陣列第一個元素\n\n<strong>`shift()`</strong> 方法可移除並返回陣列的第一個元素。\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nlet b = a.shift();\nconsole.log(a); // [2, 3, 4, 5, 6, 7, 8]\nconsole.log(b); // 1\n```\n\n---\n\n## unshift() - 將資料添加至陣列最前方\n\n<strong>`unshift()`</strong> 方法可以將一或多個元素添加至陣列的第一個位置。\n\n```javascript\nlet a = [1, 2, 3, 4];\na.unshift(100, 200);\nconsole.log(a); // [100, 200, 1, 2, 3, 4]\n```\n\n---\n\n## reverse() - 反轉陣列\n\n<strong>`reverse()`</strong> 方法會將陣列的順序顛倒。\n\n```javascript\nlet a = [1, 2, 3, 4, 5];\na.reverse();\nconsole.log(a); // [5, 4, 3, 2, 1]\n```\n\n---\n\n## splice() - 移除或添加陣列元素\n\n<strong>`splice()`</strong> 方法可用於移除或添加陣列中的元素，其接受三個參數：\n\n1. **位置**：要修改的開始索引（必填）\n2. **刪除數量**：要刪除的元素數量（選填）\n3. **新增元素**：要添加的元素（選填）\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\na.splice(5); // 移除第 5 個位置之後的所有元素\nconsole.log(a); // [1, 2, 3, 4, 5]\n\nlet b = [1, 2, 3, 4, 5, 6, 7, 8];\nb.splice(5, 2); // 移除第 5 個位置的兩個元素\nconsole.log(b); // [1, 2, 3, 4, 5, 8]\n\nlet c = [1, 2, 3, 4, 5, 6, 7, 8];\nc.splice(5, 2, 60, 70); // 移除第 5 個位置的兩個元素並新增 60 和 70\nconsole.log(c); // [1, 2, 3, 4, 5, 60, 70, 8]\n```\n\n---\n\n## sort() - 對陣列進行排序\n\n<strong>`sort()`</strong> 方法用來對陣列中的元素進行排序。它可以接受一個比較函式作為參數，以決定排序順序。\n\n```javascript\nlet a = [4, 3, 1, 5, 7, 6, 2];\na.sort((x, y) => y - x); // 降序排列\nconsole.log(a); // [7, 6, 5, 4, 3, 2, 1]\n\na.sort((x, y) => x - y); // 升序排列\nconsole.log(a); // [1, 2, 3, 4, 5, 6, 7]\n```\n\n<div class=\"note warning\">\n  <strong>注意：</strong>若不提供比較函式，預設會將元素轉換成字串並按照 Unicode 順序排序，可能導致不正確的數字排序。結果如下：\n</div>\n\n```javascript\nlet a = [1, 3, 22, 4, 5, 37, 6, 2, 57, 10, 11];\na.sort();\nconsole.log(a); // [1, 10, 11, 2, 22, 3, 37, 4, 5, 57, 6]\n```\n\n---\n\n## copyWithin() - 複製陣列元素\n\n`copyWithin()` 方法用於複製陣列中的某些元素，並將它們放置到同一陣列的指定位置。該方法接受三個參數：\n\n```javascript\na.copyWithin(target, start, end)\n```\n\n### 參數說明\n\n1. **target**：要置換的開始索引（必填）。\n2. **start**：從何處開始複製（選填，預設為 0）。\n3. **end**：停止複製的索引前一個位置（選填，預設為陣列長度）。\n\n### 範例\n\n```javascript\nlet a = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸'];\na.copyWithin(2);\nconsole.log(a); // ['甲', '乙', '甲', '乙', '丙', '丁', '戊', '己', '庚', '辛']\n```\n\n### 運作方式\n\n當你執行 `a.copyWithin(2)` 時，方法的運作流程如下：\n\n- **原始數組**: `['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸']`\n- **target**: `2` （填充從索引 `2` 開始）\n- **start**: 默認為 `0`（從索引 `0` 開始複製，即數字 `'甲'`）。\n- **end**: 默認為數組的結尾，即 `10`。\n\n### 複製過程\n\n1. **複製數據**: 從索引 `0` 開始複製到數組結尾，複製的數據為 `['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸']`。\n2. **填充數組**: 從索引 `2` 開始填充：\n   - `a[2]` 被設置為 `'甲'` （來自 `a[0]`）\n   - `a[3]` 被設置為 `'乙'` （來自 `a[1]`）\n   - `a[4]` 被設置為 `'丙'` （來自 `a[2]`）\n   - `a[5]` 被設置為 `'丁'` （來自 `a[3]`）\n   - `a[6]` 被設置為 `'戊'` （來自 `a[4]`）\n   - `a[7]` 被設置為 `'己'` （來自 `a[5]`）\n   - `a[8]` 被設置為 `'庚'` （來自 `a[6]`）\n   - `a[9]` 被設置為 `'辛'` （來自 `a[7]`）\n\n3. **最終結果**:\n   - 數組變為 `['甲', '乙', '甲', '乙', '丙', '丁', '戊', '己', '庚', '辛']`\n\n---\n\n## fill() - 替換陣列中的所有元素\n\n<strong>`fill()`</strong> 方法會將陣列中的所有元素替換為指定的值。它接受三個參數：\n\n1. **要填充的值**（必填）\n2. **開始索引**（選填，預設為 0）\n3. **結束索引**（選填，預設為陣列長度）\n\n```javascript\nlet a = [1, 2, 3, 4, 5];\na.fill('a');\nconsole.log(a); // ['a', 'a', 'a', 'a', 'a']\n```\n\n### 使用開始索引\n\n```javascript\nlet b = [1, 2, 3, 4, 5];\nb.fill(3, 2);\nconsole.log(b); // [1, 2, 3, 3, 3]\n```\n\n### 使用結束索引\n\n```javascript\nlet c = [1, 2, 3, 4, 5,\n\n 6, 7, 8];\nc.fill('c', 3, 5);\nconsole.log(c); // [1, 2, 3, 'c', 'c', 6, 7, 8]\n```\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"解決 Chrome DevTools 中無法貼上的問題","url":"/browser/no-paste-in-devtools/","content":"\n在使用新電腦或尚未進行設定的情況下，您可能會在 Chrome 的 DevTools Console 中嘗試貼上文字時，遇到以下警告，導致貼上操作失敗：\n\n```bash\nWarning: Don’t paste code into the DevTools Console that you don’t understand or haven’t reviewed yourself. This could allow attackers to steal your identity or take control of your computer. Please type ‘allow pasting’ below and hit Enter to allow pasting.\n```\n\n![無法在 DevTools 中貼上](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Browser%2Fno%20paste%20in%20devtools.png?alt=media&token=3cd0c6ca-81ba-471a-b251-76b9172d6fe1)\n\n### 解決步驟\n\n要解決此問題，您只需在 DevTools Console 中輸入 `allow pasting`，然後按 Enter 鍵。當您看到 `allow pasting` 變為淡藍色後，便可以正常使用貼上功能。\n\n![設定貼上功能](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Browser%2Fno%20paste%20in%20devtools%20setting.png?alt=media&token=0be67e1b-a4e3-4480-aee0-7609f25d480b)\n\n這樣您就可以順利進行操作了！如果您有其他問題，隨時歡迎提問。\n","tags":["Browser","Chrome","DevTools"],"categories":["Browser"]},{"title":"JavaScript Array 實戰用法","url":"/javascript/array-practical-uses/","content":"\n## 陣列某數相加\n\n計算購物車中的所有商品總價。\n\n```javascript\nlet cart = [\n    {\n        final_total: 1000,\n        id: '-MuukdVMGpp1N2qWpLCi',\n        product: {\n          num:1\n        },\n        product_id: '-MrqF6_cBLw8r2klq2xF',\n        qty: 2,\n        total: 1000,\n    },\n    {\n        final_total: 2000,\n        id: '-MuukdxAR0diJfsf1g_Y',\n        product: {\n          num:1\n        },\n        product_id: '-MsDLuC3zDUsalUMzm2w',\n        qty: 3,\n        total: 2000,\n    }, \n    {\n        final_total: 500,\n        id: '-MuumZnqYPyEOVX1BGzS',\n        product: {\n          num:1\n        },\n        product_id: '-MrgpCOiALq9tT5Uu4vv',\n        qty: 5,\n        total: 500,\n    }\n];\n\n// 計算 cart 裡面的 total\nlet price = cart.map((item) => item.total).reduce((a, b) => a + b, 0);\nconsole.log(price); // 3500\n```\n\n## 陣列底下的陣列中物件某數相加\n\n計算具有相同 `text` 的 `num` 值總和。\n\n```javascript\nconst data = [\n  {\n    id: 1,\n    u: 10,\n    total: [\n      {\n        text: '1',\n        num: 99,\n      }\n    ]\n  },\n  {\n    id: 1,\n    u: 12,\n    total: [\n      {\n        text: '1',\n        num: 100,\n      }\n    ]\n  },\n  {\n    id: 2,\n    total: [\n      {\n        text: '2',\n        num: 50,\n      }\n    ]\n  },\n  {\n    id: 1,\n    u: 19,\n    total: [\n      {\n        text: '3',\n        num: 11,\n      }\n    ]\n  },\n]\n\nconst dataTemp = [];\nconst filterData = data.filter(i => i.id === 1).map(m => dataTemp.push(...m.total));\n\n// 計算相同的 text 相加\nconst res = Array.from(dataTemp.reduce((m, { text, num }) => m.set(text, (m.get(text) || 0) + num), new Map), ([text, num]) => ({ text, num }));\n\nconsole.log(res);\n// [\n//   { \"text\": \"1\", \"num\": 199 },\n//   { \"text\": \"3\", \"num\": 11 }\n// ]\n```\n\n## 陣列取最大值\n\n尋找陣列中的最大值。\n\n```javascript\nconst values = [1, 2, 300, 5, 6];\nconsole.log(Math.max(...values)); // 300\n```\n\n## 陣列統計 skills 並移除重複值並排序\n\n統計所有開發者的技能，並移除重複值。\n\n```javascript\nconst developers = [\n  {\n    id: 1,\n    name: \"John\",\n    skills: [\"HTML\", \"React\", \"Javascript\", \"Java\"],\n  },\n  {\n    id: 2,\n    name: \"Jane\",\n    skills: [\"HTML\", \"CSS\", \"JavaScript\", \"React\", \"Redux\", \"NodeJS\"],\n  },\n  {\n    id: 3,\n    name: \"Jack\",\n    skills: [\"HTML\", \"CSS\", \"JavaScript\", \"React\", \"Redux\", \"NodeJS\"],\n  },\n];\n\nconst result1 = developers.reduce((allSkills, student) => new Set([...allSkills, ...student.skills]), []);\nconst result2 = developers.reduce((allSkills, student) => Array.from(new Set([...allSkills, ...student.skills])), []);\n\nconsole.log(result1); // {'HTML', 'React', 'Javascript', 'Java', 'CSS', 'JavaScript', 'Redux', 'NodeJS'}\nconsole.log(result2); // ['HTML', 'React', 'Javascript', 'Java', 'CSS', 'JavaScript', 'Redux', 'NodeJS']\n```\n\n## 陣列(找到/移除)相同值\n\n找到陣列中符合特定鍵的項目，並分為兩個陣列。\n\n```javascript\nconst data = [\n  {\n    id: 1,\n    name: '類型',\n    key: 'type',\n    show: true,\n  },\n  {\n    id: 2,\n    name: '價格',\n    key: 'price',\n    show: true,\n  },\n  {\n    id: 3,\n    name: '名稱',\n    key: 'name',\n    show: true,\n  },\n]\nconst selectedKeys = ['type', 'name'];\nconst findMatches = data.filter(item => selectedKeys.indexOf(item.key) !== -1); // 找到相同值\nconst removeDuplicates = data.filter(item => selectedKeys.indexOf(item.key) === -1); // 移除相同值\nconsole.log(findMatches);\nconsole.log(removeDuplicates);\n```\n\n## `filter()` & `match()` - 搜尋陣列\n\n以下範例展示如何使用 `filter()` 和 `match()` 方法來搜尋陣列中的特定項目。\n\n```javascript\nconst list = [\n  ['小明', '小小明', '小明明'],\n  ['小華', '小小華', '小華華'],\n  ['小美', '小小美', '小美美'],\n];\n\n// 使用展開運算符將二維陣列展平為一維陣列\nconst newList = [].concat(...list);\n// newList = ['小明', '小小明', '小明明', '小華', '小小華', '小華華', '小美', '小小美', '小美美']\n\n// 使用 filter() 和 match() 搜尋包含 \"小小\" 的項目\nconst result = newList.filter((value) => value.match('小小'));\n\nconsole.log(result); // 輸出: [\"小小明\", \"小小華\", \"小小美\"]\n```\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript Array 遍歷與轉換方法","url":"/javascript/array-iteration-and-transformation/","content":"\n## forEach\n\n使用 `forEach` 方法遍歷陣列，對每個元素執行指定的函數。\n\n```javascript\nlet data = [1, 2, 3];\ndata.forEach(function(item, index, array) {\n    console.log(item, index, array);\n    // 結果如下\n    // 1, 0, [1, 2, 3]\n    // 2, 1, [1, 2, 3]\n    // 3, 2, [1, 2, 3]\n});\n```\n\n## map\n\n1. `map` 方法能將原始陣列運算後，重新組合並回傳一個新陣列。\n2. 不會影響原本的陣列。\n3. 若未使用 `return`，則會回傳 `undefined`。\n\n```javascript\nlet data = [1, 2, 3];\nlet newData = data.map(function(item) {\n    return item * item;\n});\nconsole.log(data); // [1, 2, 3]\nconsole.log(newData); // [1, 4, 9]\n```\n\n```javascript\nlet data = [1, 5, 10, 8, 4, 2];\nlet newData = data.map(function(item) {\n    return item > 5;\n});\n\n// 組合物件\nlet newData1 = data.map(function(item) {\n    let obj = {};\n    obj.checkNum = item > 5;\n    return obj;\n});\nconsole.log(data); // [1, 5, 10, 8, 4, 2]\nconsole.log(newData); // [false, false, true, true, false, false]\nconsole.log(newData1); // [{…}, {…}, {…}, {…}, {…}, {…}]\n```\n\n### forEach 與 map 差別\n\n```javascript\nlet data = [1, 2, 3];\nlet newData = data.forEach(function(item) {\n    return item * item;\n});\nconsole.log(data); // [1, 2, 3]\n// forEach 不會返回新陣列，故 newData 為 undefined\nconsole.log(newData); // undefined\n```\n\n## filter\n\n使用 `filter` 方法篩選出符合條件的元素，並回傳新陣列。\n\n```javascript\nlet data = [1, 4, 10, 15];\nlet newData = data.filter(function(item) {\n    return item > 5;\n});\nconsole.log(data); // [1, 4, 10, 15]\nconsole.log(newData); // [10, 15]\n```\n\n範例：篩選及格的學生。\n\n```javascript\nlet scoreData = [\n    { name: '阿呆', score: 100 },\n    { name: '阿美', score: 61 },\n    { name: '阿新', score: 40 },\n];\n\n// 篩選及格的人\nlet filterScore = scoreData.filter(function(item) {\n    return item.score >= 60;\n});\nconsole.log(filterScore);\n// (2) [{…}, {…}]\n```\n\n## find\n\n使用 `find` 方法尋找第一筆符合條件的元素。\n\n```javascript\nlet data = [1, 4, 10, 15];\nlet newData = data.find(function(item) {\n    return item > 5;\n});\nconsole.log(data); // [1, 4, 10, 15]\nconsole.log(newData); // 10\n```\n\n## findIndex\n\n使用 `findIndex` 方法尋找第一筆符合條件的元素的索引值。\n\n```javascript\nlet data = [10, 20, 30];\nlet newData = data.findIndex(function(item) {\n    return item >= 15;\n});\nconsole.log(data); // [10, 20, 30]\nconsole.log(newData); // 1\n```\n\n## reduce\n\n使用 `reduce` 方法將陣列內數值進行累加。\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconst total = numbers.reduce((a, b) => {\n    return a + b;\n}, 0);\nconsole.log(total); // 15\n```\n\n## at\n\n使用 `at` 方法尋找陣列位置資料。\n\n```javascript\nconst array1 = [5, 12, 8, 130, 44, 66, 99, 10, 50];\nconsole.log(array1.at(-1)); // 50\nconsole.log(array1.at(-3)); // 99\n```\n\n## concat\n\n使用 `concat` 方法合併兩個或多個陣列。\n\n```javascript\nconst array1 = ['a', 'b', 'c'];\nconst array2 = ['d', 'e', 'f'];\nconst array3 = array1.concat(array2);\nconsole.log(array3); // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n```\n\n## join\n\n使用 `join` 方法將陣列元素合併為字串。\n\n```javascript\nconst arr = ['nick', 'chang'];\nconsole.log(arr.join(' ')); // nick chang\n\nconst obj = [{ id: 1 }, { id: 2 }];\nconsole.log(obj.join(' ')); // [object Object] [object Object]\n\nconst integrated = [1, 2, 'asd', '!@#df', [123, 999, { id: 100 }]];\nconsole.log(integrated.join('-')); // 1-2-asd-!@#df-123,999,[object Object]\n```\n\n## flat()\n\n`flat()` 方法用於將多維陣列展平為一個單層陣列。它接受一個可選的參數，指定展平的層數。\n\n### 基本用法\n\n```javascript\nvar arr1 = [1, 2, [3, 4]];\nconsole.log(arr1.flat()); \n// 輸出: [1, 2, 3, 4]\n```\n\n### 展平一層\n\n```javascript\nvar arr2 = [1, 2, [3, 4, [5, 6]]];\nconsole.log(arr2.flat());\n// 輸出: [1, 2, 3, 4, [5, 6]]\n```\n\n### 展平多層\n\n```javascript\nvar arr3 = [1, 2, [3, 4, [5, 6]]];\nconsole.log(arr3.flat(2));\n// 輸出: [1, 2, 3, 4, 5, 6]\n```\n\n### 展平至任意深度\n\n使用 `Infinity` 作為參數，可以展開任意深度的巢狀陣列：\n\n```javascript\nvar arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];\nconsole.log(arr4.flat(Infinity));\n// 輸出: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n### 處理複雜結構\n\n```javascript\nvar arr5 = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, [\"string\", { type: \"物件\" }]];\nconsole.log(arr5.flat(Infinity));\n// 輸出: [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, \"string\", { type: \"物件\" }];\n```\n\n### 移除空項\n\n`flat()` 方法還可以用來移除陣列中的空項：\n\n```javascript\nvar arr6 = [1, 2, , 4, 5];\nconsole.log(arr6.flat());\n// 輸出: [1, 2, 4, 5]\n```\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript 事件 (event)","url":"/javascript/event/","content":"\n## addEventListener 監聽綁定\n\n使用 `addEventListener` 方法來監聽 DOM 事件，語法如下：\n\n```javascript\naddEventListener('event', function, true / false)\n// 第三個參數可省略，預設為 false\n// true (事件捕捉 - event capturing) - 從指定元素向外查找\n// false (事件氣泡 - event bubbling) - 從指定元素向內查找\n\n// 例子：\naddEventListener('click', function() {\n}, false)\n```\n\n```html\n<style>\n  .all {\n    height: 200px;\n    width: 200px;\n    background: red;\n  }\n  .box {\n    height: 100px;\n    width: 100px;\n    background: #000;\n  }\n</style>\n\n<h1>true</h1>\n<div class=\"all\">\n  <div class=\"box\"></div>\n</div>\n\n<script>\n  var bodys = document.querySelector('.all');\n  var el = document.querySelector('.box');\n  el.addEventListener('click', function() {\n    console.log('box');\n  }, true); // 捕捉模式\n  bodys.addEventListener('click', function() {\n    console.log('body');\n  }, true);\n</script>\n```\n\n![Set addEventListener to true](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20addEventListener%20true.gif?alt=media&token=ae0143e0-02e3-4d02-915f-79d065cddb22)\n![Set addEventListener to false](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20addEventListener%20false.gif?alt=media&token=29726f49-7d2e-417c-9868-90ea5aa4e9e2)\n\n## stopPropagation - 中止冒泡事件\n\n如果你希望阻止事件的冒泡，可以使用 `stopPropagation()` 方法：\n\n```html\n<style>\n  .all {\n    height: 200px;\n    width: 200px;\n    background: red;\n  }\n  .box {\n    height: 100px;\n    width: 100px;\n    background: #000;\n  }\n</style>\n\n<h1>true</h1>\n<div class=\"all\">\n  <div class=\"box\"></div>\n</div>\n\n<script>\n  var bodys = document.querySelector('.all');\n  var el = document.querySelector('.box');\n  el.addEventListener('click', function(e) {\n    e.stopPropagation(); // 中止冒泡事件\n    console.log('box');\n  }, false);\n  bodys.addEventListener('click', function() {\n    console.log('body');\n  }, false);\n</script>\n```\n\n![JavaScript stopPropagation](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20stopPropagation.gif?alt=media&token=af0ec4f7-5cbf-4c99-a738-25ff55f44aa1)\n\n## preventDefault - 取消預設觸發行為\n\n可以使用 `preventDefault()` 方法來取消元素的預設行為：\n\n```html\n<a href=\"https://tw.yahoo.com/\" class=\"link\">link</a>\n<script>\n  var el = document.querySelector('.link');\n  el.addEventListener('click', function(e) {\n    e.preventDefault();\n    console.log('已取消連結');\n  });\n</script>\n```\n\n![JavaScript preventDefault](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20preventDefault.gif?alt=media&token=7cdcf461-1d92-4432-a483-f7a23d10731c)\n\n## target - 了解當前元素位置\n\n使用 `e.target` 來獲取當前事件目標：\n\n```html\n<style>\n  .header {\n    background: pink;\n  }\n  .ul {\n    padding: 1rem;\n  }\n  li {\n    background: #fff;\n    padding: 1rem;\n  }\n</style>\n\n<header class=\"header\">\n  <ul class=\"ul\">\n    <li>123456789</li>\n  </ul>\n</header>\n<script>\n  var el = document.querySelector('.header');\n  el.addEventListener('click', function(e) {\n    console.log('target:', e.target);\n    console.log('nodeName:', e.target.nodeName);\n  });\n</script>\n```\n\n![JavaScript target](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20target.gif?alt=media&token=8e9e71da-0545-4d2e-96f8-543355d4855f)\n\n## change - 表單內容變更時觸發\n\n使用 `change` 事件來監聽表單的選擇變化：\n\n```html\n<select name=\"area\" id=\"area\">\n  <option value=\"前鎮區\">前鎮區</option>\n  <option value=\"苓雅區\">苓雅區</option>\n</select>\n<ul class=\"list\"></ul>\n\n<script>\n  var area = document.getElementById('area');\n  var list = document.querySelector('.list');\n  var country = [\n    { farmer: '查理', place: '前鎮區' },\n    { farmer: '小花', place: '前鎮區' },\n    { farmer: '大白', place: '苓雅區' },\n  ];\n\n  function updatedList(e) {\n    var select = e.target.value;\n    var str = ''; // 組資料用\n    country.forEach(function(item) {\n      if (select === item.place) {\n        str += `<li>${item.farmer}</li>`;\n      }\n    });\n    list.innerHTML = str;\n  }\n  \n  area.addEventListener('change', updatedList, false);\n</script>\n```\n\n![JavaScript change](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20change.gif?alt=media&token=8812b1f3-dcb6-4df1-bff3-6b568df5be33)\n\n## keyCode - 鍵盤事件\n\n監聽鍵盤事件並使用 `keyCode` 來判斷按鍵：\n\n```html\n<style>\n  .list {\n    position: relative;\n    width: 100px;\n    height: 100px;\n    list-style-type: none;\n    background: pink;\n  }\n  .round {\n    position: absolute;\n    bottom: 0;\n    width: 25px;\n    height: 25px;\n    background: #000;\n    border-radius: 50%;\n    transition: 1s cubic-bezier(0.25, 0.1, 0.49, 0.16);\n  }\n  .round-1 {\n    left: 10px;\n  }\n  .round-2 {\n    left: 50%;\n    transform: translateX(-50%);\n  }\n  .round-3 {\n    right: 10px;\n  }\n</style>\n\n<ul class=\"list\">\n  <li class=\"round round-1\"></li>\n  <li class=\"round round-2\"></li>\n  <li class=\"round round-3\"></li>\n</ul>\n\n<script>\n  var body = document.body;\n  function keydown(e) {\n    switch (e.keyCode) {\n      case 49: // 1\n        document.querySelector('.round-1').style.bottom = '200px';\n        break;\n      case 50: // 2\n        document.querySelector('.round-2').style.bottom = '200px';\n        break;\n      case 51: // 3\n        document.querySelector('.round-3').style.bottom = '200px';\n        break;\n    }\n  }\n  body.addEventListener('keydown', keydown, false);\n</script>\n```\n\n![JavaScript keyCode](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20keyCode.gif?alt=media&token=b7b07842-1444-4bbb-bb8b-63f2e5a8e1ad)\n\n## blur - 離開焦點時觸發事件\n\n當 input 為空時顯示錯誤訊息：\n\n```html\n<style>\ninput {\n  width: 50px;\n}\n.error {\n  display: none;\n  color: red;\n}\n.error.show {\n  display: block;\n}\n</style>\n\n價目表：咖啡50元，蛋糕100元<br />\n我要\n<input type=\"text\" class=\"input1\" value=\"0\"> 杯咖啡，\n<input type=\"text\" class=\"input2\" value=\"0\"> 份蛋糕\n<button type=\"button\" class=\"btn\">計算</button>\n<div class=\"error\">數量錯誤</div><br />\n總共 <span class=\"moneys\">0</span>元\n\n<script>\n  var money = '';\n  var input1 = document.querySelector('.input1');\n  var input2 = document.querySelector('.input2');\n  var error = document.querySelector('.error');\n  var btn = document.querySelector('.btn');\n  var moneys = document.querySelector('.moneys');\n\n  function checkNum(e) {\n    if (e.target.value === '') {\n      error.classList.add('show');\n    } else {\n      error.classList.remove('show');\n    }\n  }\n\n  function checkMoney(e) {\n    if (input1.value !== '' && input2.value !== '') {\n      error.classList.remove('show');\n      money = input1.value * 50 + input2.value * 100;\n    } else {\n      error.classList.add('show');\n      money = 0;\n    }\n    moneys.textContent = money;\n  }\n\n  input1.addEventListener('blur', checkNum, false);\n  input2.addEventListener('blur', checkNum, false);\n  btn.addEventListener('click', checkMoney, false);\n</script>\n```\n\n![JavaScript blur](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20blur.gif?alt=media&token=0859bb20-0e50-47c5-a837-b2ca129f9992)\n\n## mouse - 當滑鼠滑入指定內容時觸發\n\n監聽滑鼠移動事件：\n\n```html\n<style>\n.box {\n  width: 50px;\n  height: 50px;\n  background: #000;\n}\n</style>\n\n<div class=\"box\"></div>\n<script>\n  var box = document.querySelector('.box');\n  function mousemove() {\n    console.log('mousemove start');\n  }\n  box.addEventListener('mousemove', mousemove, false);\n</script>\n```\n\n![JavaScript mouse](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20mouse.gif?alt=media&token=536dd783-1fbe-4c56-970b-a73a891d92d7)\n\n## screen、page、client - 網頁座\n\n標的差異\n\n- `event.screenX`, `event.screenY`：相對於整個螢幕的座標。\n- `event.pageX`, `event.pageY`：相對於整個網頁的座標。\n- `event.clientX`, `event.clientY`：相對於可視窗口的座標。\n\n## 事件監聽優化 - 從父元素來監聽子元素\n\n### 題目：點擊 li 顯示內容\n\n**範例一**：querySelector 只取得第一個 li，因此點擊第二個會失效。\n\n```html\n<style>\n  .list {\n    background: #989898;\n    padding: 50px;\n  }\n</style>\n\n<ul class=\"list\">\n  <li>小白</li>\n  <li>阿花</li>\n</ul>\n\n<script>\n  var box = document.querySelector('.list li');\n  function listName(e) {\n    console.log(e.target.textContent);\n  }\n  box.addEventListener('click', listName, false);\n</script>\n```\n\n![JavaScript even Example 1](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20even%20Example%201.gif?alt=media&token=61b70b61-2252-417f-92a7-f27793a16dc7)\n\n**範例二**：從父元素監聽，並過濾不必要的事件。\n\n```html\n<style>\n  .list {\n    background: #989898;\n    padding: 50px;\n  }\n</style>\n\n<ul class=\"list\">\n  <li>小白</li>\n  <li>阿花</li>\n</ul>\n\n<script>\n  var box = document.querySelector('.list');\n  function listName(e) {\n    if (e.target.nodeName !== \"LI\") return; // 重要過濾條件\n    console.log(e.target.textContent);\n  }\n  box.addEventListener('click', listName, false);\n</script>\n```\n\n![JavaScript even Example 2-1](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20even%20Example%202-1.gif?alt=media&token=37cf999b-b0ae-455d-a326-dde2b0072750)\n![JavaScript even Example 2-2](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20even%20Example%202-2.gif?alt=media&token=48cb48f7-9995-4f8d-bd78-3e0c4d3a587a)\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript 樣板字面值（Template Literals）在 VS Code 快速產生 emmet","url":"/vscode/template-literals-configuration/","content":"\n## 前言\n\n在使用VS Code進行前端開發時，可能會遇到樣板字面值（Template literals）無法通過按下 Tab 鍵快速展開 Emmet 的情況。以下是解決此問題的步驟，讓你的編碼更加高效。\n\n## 1. 打開 VSCode 設定\n\n首先，進入 VSCode 的設定頁面，然後找到 `settings.json` 檔案。如果找不到 `settings.json`，可以在設定中搜索關鍵字「Launch」。\n\n![VS Code settings.json](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/VS_Code%2FVS%20Code%20settings.png?alt=media&token=5a81228c-0f7a-4f97-be3a-2827536a0e63)\n\n## 2. 修改設定\n\n將以下的設定語法貼入 `settings.json` 中，然後重啟 VSCode：\n\n```json\n{\n    // 啟用 emmet 的 Tab 自動展開\n    \"emmet.triggerExpansionOnTab\": true,\n    // 定義 template 的展開方式\n    \"emmet.includeLanguages\": {\n        \"javascript\": \"javascriptreact\",\n        \"vue-html\": \"html\",\n        \"plaintext\": \"jade\",\n        \"ejs\": \"html\"\n    }\n}\n```\n\n這段設定將幫助 VSCode 認識不同語言的樣板擴展，並啟用 Tab 鍵快速展開功能。\n\n## 3. 測試設置\n\n在 `<script></script>` 區域內測試 Emmet 展開功能。你可以輸入如下代碼：\n\n```html\n<script>\n    `li`  // 在 li 後方按下 Tab 鍵\n</script>\n```\n\n這樣應該能夠順利展開為 `<li></li>` 標籤。\n\n## 4. 如果仍然無法展開\n\n如果上述方法無法解決問題，可以嘗試清空 `settings.json` 的內容，然後重新貼上上面的設定，最後重啟 VSCode。\n\n這些步驟應該能夠幫助你解決 VSCode 中樣板字面值的 Emmet 展開問題，讓你的開發過程更流暢。\n","tags":["VSCode"],"categories":["VSCode"]},{"title":"JavaScript 樣板字面值（Template Literals）","url":"/javascript/javascript-template-literals/","content":"\n## 傳統的寫法\n\n在傳統的寫法中，我們需要使用 `+` 和 `\\` 來分隔字串和變數，以及處理換行，這樣容易導致錯誤或遺漏。\n\n```javascript\nconst people = [\n  { name: '小明', friends: 2 },\n  { name: '阿姨', friends: 999 },\n  { name: '杰倫', friends: 0 }\n];\n\nlet originUl = '<ul>\\\n  <li>我叫做 ' + people[0].name + '</li>\\\n  <li>我叫做 ' + people[1].name + '</li>\\\n  <li>我叫做 ' + people[2].name + '</li>\\\n</ul>';\n\nconsole.log(originUl);\n```\n\n![template literals previous](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FTemplate%20literals%20previous%20writing%20style.png?alt=media&token=a4f7a0bf-1460-488c-b79a-1aee80fe4bd9)\n\n---\n\n## 樣板字面值的寫法\n\n使用樣板字面值（Template literals），我們可以用反引號 `` ` `` 將字串包起來，這樣就能夠更簡潔地插入變數和換行。\n\n```javascript\nlet New1 = `\n<ul>\n  <li>我叫做 ${people[0].name}</li>\n  <li>我叫做 ${people[1].name}</li>\n  <li>我叫做 ${people[2].name}</li>\n</ul>\n`;\n\nconsole.log(`我是New1 ${New1}`);\n```\n\n- 結果如下圖：\n\n![template literals](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FTemplate%20literals%20writing%20style.png?alt=media&token=39706b00-9f92-42b6-bbbd-8068c4dcba38)\n\n---\n\n## 使用迴圈生成列表\n\n我們也可以使用 `map` 方法來迴圈生成列表，這樣能夠更靈活地處理資料。\n\n```javascript\n// 使用 map 跑迴圈，\n// 如果沒有加 join('')，每個 <li> 之後會出現逗號。\n// 所以要用 join('') 移除逗號，避免出現多餘的符號。\n\nlet New2 = `\n<ul>\n  ${people.map(i => `<li>我叫做 ${i.name}</li>`).join('')}\n</ul>\n`;\n\nconsole.log(`我是New2 ${New2}`);\n```\n\n- 結果如下圖：\n\n![template literals loop](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FTemplate%20literals%20loop%20writing%20style.png?alt=media&token=f9b98925-39cb-4313-bd95-8036aac1e525)\n\n### join 補充\n\n`join` 方法的預設分隔符是逗號 `\",\"`，可以使用空字串 `''` 來替代，以便獲得想要的結果。\n\n更多關於 `join` 的信息可以參考 [MDN 文檔](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/join)。\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript 函式","url":"/javascript/functions/","content":"\n\n## 前言\n\nJavaScript 中的函式是重要的基礎，理解它們的不同寫法和特性將幫助你更好地組織和撰寫程式碼。\n\n## 函式陳述式 & 函式表達式差別\n\n### <font color=\"#f00\">函式陳述式</font>\n\n函式陳述式（Function Declaration）在程式碼中會進行提升（Hoisting），這意味著你可以在函式定義之前呼叫它。這使得它們在代碼中更靈活。\n\n```javascript\nconsole.log(numA(2)); // 4\nfunction numA(x) {\n    return x * x;\n}\n```\n\n<!-- ### <span color=\"#f00\">函式表達式</span> -->\n<span class=\"red-text\">函式表達式</span>\n\n\n函式表達式（Function Expression）則是將函式賦值給變數，這要求你必須在呼叫函式之前定義它。因此，若不按照順序撰寫，將會導致錯誤。\n\n- 錯誤的範例\n\n```javascript\nconsole.log(numA(2)); // Identifier 'numA' has already been declared\nconst numA = function (x) {\n    return x * x;\n}\n```\n\n- 正確的範例\n\n```javascript\nconst numA = function (x) {\n    return x * x;\n}\nconsole.log(numA(2)); // 4\n```\n\n## 函式陳述式、函式表達式與箭頭函式的使用方式\n\n下面是不同函式寫法的示範：\n\n```javascript\n// 函式陳述式\nfunction numA(x) {\n    return x * x;\n}\n\n// 函式表達式\nconst numB = function (x) {\n    return x * x;\n}\n\n// 箭頭函式\nconst numC = (x) => {\n    return x * x;\n}\n\n// 箭頭函式縮寫 - 沒有參數\nconst numD = () => '沒有參數';\n\n// 箭頭函式縮寫 - 單一參數\nconst numE = x => x * x;\n\n// 箭頭函式縮寫 - 多個參數\nconst numF = (x, y) => x * y;\n\nconsole.log(numA(2)); // 4\nconsole.log(numB(2)); // 4\nconsole.log(numC(2)); // 4\nconsole.log(numD()); // 沒有參數\nconsole.log(numE(2)); // 4\nconsole.log(numF(2, 3)); // 6\n```\n\n## 函式的其他特性\n\n1. **作用域（Scope）**：\n   - 函式可以訪問它所在的作用域及其外部作用域的變數。\n\n2. **回傳值**：\n   - 每個函式都有一個回傳值，若沒有使用 `return`，則預設回傳 `undefined`。\n\n3. **參數預設值**：\n   - 可以為函式參數設置預設值，這在沒有提供參數時特別有用。\n\n   ```javascript\n   const greet = (name = '世界') => `你好，${name}!`;\n   console.log(greet()); // 你好，世界!\n   console.log(greet('小明')); // 你好，小明!\n   ```\n\n4. **高階函式（Higher-order functions）**：\n   - 可以將函式作為參數傳遞或返回另一個函式，這使得函式可以非常靈活地操作。\n\n   ```javascript\n   const applyFunction = (fn, value) => fn(value);\n   const double = x => x * 2;\n   console.log(applyFunction(double, 5)); // 10\n   ```\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript 操作語法","url":"/javascript/operation-syntax/","content":"\n## parseInt()字串轉數字\n\n`parseInt()` 用於將字符串轉換為整數。以下是一些示例：\n\n```javascript\n// 轉換型別成功，如果變數開頭是數字後面是字串會取前面的數字\nlet a = '34';\nconsole.log(typeof a); // string\nconsole.log(typeof parseInt(a)); // number\n\nlet b = '50ertyetddgv';\nconsole.log(parseInt(b)); // 50\n\nlet c = '0.55';\nconsole.log(parseInt(c)); // 0\n\n// 轉換型別錯誤，如果變數開頭是中英文字或特殊符號會出現 NaN\nlet d = 'ab34c';\nconsole.log(parseInt(d)); // NaN\n\nlet e = '!99';\nconsole.log(parseInt(e)); // NaN\n\n```\n\n---\n\n## toString() 數字轉字串方法\n\n`toString()` 方法用於將數字轉換為字符串：\n\n```javascript\nlet a = 34;\nconsole.log(typeof a); // number\nconsole.log(typeof a.toString()); // string\n\nlet b = 50;\nconsole.log(b.toString()); // \"50\"\n\nlet c = 0.55;\nconsole.log(c.toString()); // \"0.55\"\n```\n\n---\n\n## toLowerCase() 字串轉小寫\n\n使用 `toLowerCase()` 將字符串轉為小寫字母：\n\n```javascript\nconst str1 = 'This Is A Apple';\nconsole.log(str1.toLowerCase()) // this is a apple\n\nconst str2 = '你好嗎 NICK';\nconsole.log(str2.toLowerCase()) // 你好嗎 nick\n\nconst str3 = 'DFGd4eg@112dFHf~fHJTg';\nconsole.log(str3.toLowerCase()) // dfgd4eg@112dfhf~fhjtg\n```\n\n---\n\n## toUpperCase() 字串轉大寫\n\n使用 `toUpperCase()` 將字符串轉為大寫字母：\n\n```javascript\nconst str1 = 'this is a apple';\nconsole.log(str1.toUpperCase()) // THIS IS A APPLE\n\nconst str2 = '你好嗎 Nick';\nconsole.log(str2.toUpperCase()) // 你好嗎 NICK\n\nconst str3 = '@2f304ge4hgjur54!';\nconsole.log(str3.toUpperCase()) // @2F304GE4HGJUR54!\n```\n\n---\n\n![JavaScript innerHTML & createElement difference](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20innerHTML%20%26%20createElement%20difference.png?alt=media&token=0d7ad439-01b4-4fc4-9998-c93e825f7d8e)\n\n## innerHTML 設定/取得標籤\n\n`innerHTML` 特性可以清空標籤內的內容，並塞入自定義的內容：\n\n```html\n<h1 class=\"titleClass\">\n  <a href=\"#\">title</a>\n</h1>\n<script>\n  var el = document.querySelector('.titleClass').innerHTML;\n  console.log(el); // <a href=\"#\">title</a>\n</script>\n```\n\n### `innerHTML` 搭配 `for` 迴圈\n\n```html\n<ul class=\"list\"></ul>\n<script>\n  var farms=[\n    {\n      farmer:'卡斯柏',\n      dogs:['張母是','小白'],\n    },\n    {\n      farmer:'老張',\n      dogs:['欣欣'],\n    },\n  ]\n\n  var el = document.querySelector('.list');\n  var len = farms.length;\n  var str = ''; // 累加用\n  for(var i=0;i<len;i++){\n    if(farms[i].dogs.length > 1){\n      var content = `<li>第 ${i + 1} 農場的主人是 ${farms[i].farmer} ，她的寵物有 ${farms[i].dogs.length} 隻，分別叫做 ${farms[i].dogs}</li>`;\n    }else{\n      var content = `<li>第 ${i + 1} 農場的主人是 ${farms[i].farmer} ，她的寵物有 ${farms[i].dogs.length} 隻，叫做 ${farms[i].dogs}</li>`;\n    }\n    str+=content;\n  }\n  el.innerHTML = str;\n</script>\n```\n\n**結果如下**：\n\n- 第 1 農場的主人是 卡斯柏 ，她的寵物有 2 隻，分別叫做 張母是,小白\n- 第 2 農場的主人是 老張 ，她的寵物有 1 隻，叫做 欣欣\n\n---\n\n## createElement 新增 HTML 標籤\n\n使用 `createElement()` 方法插入新的 HTML 標籤：\n\n```html\n<h1 class=\"title\">\n  <em>title</em>\n</h1>\n\n<script>\n// createElement() 插入 HTML 標籤\n// appendChild 動態插入子節點\nvar str = document.createElement('em'); // 準備插入 em 標籤\nstr.textContent = '1234'; // em 標籤內容\n// 目前 str = <em>1234</em>\ndocument.querySelector('.title').appendChild(str);\n</script>\n```\n\n**結果如下**：\n![createElement() 插入 HTML 標籤](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20createElement%20appendChild.png?alt=media&token=4017bf45-6775-4ecd-b976-58570a964694)\n\n### `createElement` 搭配 `for` 迴圈\n\n```html\n<ul class=\"list\"></ul>\n<script>\n  var farms=[\n    {\n      farmer:'卡斯柏',\n      dogs:['張母是','小白'],\n    },\n    {\n      farmer:'老張',\n      dogs:['欣欣'],\n    },\n  ]\n\n  var el = document.querySelector('.list');\n  var len = farms.length;\n  for(var i=0;i<len;i++){\n    var str = document.createElement('li');\n    if(farms[i].dogs.length > 1){\n      str.textContent = `第 ${i + 1} 農場的主人是 ${farms[i].farmer} ，她的寵物有 ${farms[i].dogs.length} 隻，分別叫做 ${farms[i].dogs}`;\n    }else{\n      str.textContent = `第 ${i + 1} 農場的主人是 ${farms[i].farmer} ，她的寵物有 ${farms[i].dogs.length} 隻，叫做 ${farms[i].dogs}`;\n    }\n    el.appendChild(str);\n  }\n</script>\n```\n\n**結果如下**：\n\n- 第 1 農場的主人是 卡斯柏 ，她的寵物有 2 隻，分別叫做 張母是,小白\n- 第 2 農場的主人是 老張 ，她的寵物有 1 隻，叫做 欣欣\n\n---\n\n## textContent 設定/取得標籤裡的內容\n\n```html\n<h1 class=\"titleClass\">\n  <a href=\"#\">title</a>\n</h1>\n<script>\n  var el = document.querySelector('.titleClass a');\n  console.log(el.textContent); // title\n</script>\n```\n\n---\n\n## `setAttribute` 設定屬性\n\n`setAttribute('屬性', '修改成')`，例如：\n\n```javascript\nsetAttribute('href', 'https://tw.yahoo.com/');\n```\n\n`setAttribute` 方法會清空原有屬性並設置新值，因此如果是 `class`，將變為單一個。\n\n例如：\n\n```html\n<div class=\"strId adwd\">123456789</div>\n```\n\n在 JS 中使用：\n\n```javascript\nvar el = document.querySelector('.strId');\nel.setAttribute('class', 'abc'); // 修改為單一 class\n```\n\n結果將變為：\n\n```html\n<div class=\"abc\">123456789</div>\n```\n\n```html\n<style>\n  .strId {\n    color: red;\n  }\n</style>\n<h1 class=\"titleClass\">\n  <a href=\"#\">title</a>\n</h1>\n<div class=\"str\">123456789</div>\n<script>\n  var el = document.querySelector('.titleClass a');\n  var el2 = document.querySelector('.str');\n  el.setAttribute('href', 'https://tw.yahoo.com/'); // 修改 a 連結\n  el2.setAttribute('id', 'strId'); // 新增 id\n</script>\n```\n\n**結果如下**：\n![JavaScript setAttribute](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20setAttribute.png?alt=media&token=6fcb79c0-609d-45a9-a41d-63624a2ce0d5)\n\n---\n\n## getAttribute 取得屬性\n\n使用 `getAttribute('屬性')` 來取得元素的屬性，例如：\n\n```html\n<style>\n  .strId{\n    color: red;\n  }\n</style>\n<h1 class=\"titleClass\">\n  <a href=\"https://123.com\">title</a>\n</h1>\n\n<script>\n  var el = document.querySelector('.titleClass a').getAttribute('href')\n  console.log(el) // https://123.com\n</script>\n\n```\n\n---\n\n## `classList.add()` 新增 class\n\n使用 `classList.add()` 方法新增一個或多個 class：\n\n```html\n  <div id=\"id\" class=\"a1\">請看 class name</div>\n\n  <script>\n    // classList.add 新增\n    document.getElementById(\"id\").classList.add('a2');\n    // classList.add 新增多筆\n    // document.getElementById(\"id\").classList.add('a2', 'a3', 'a4');\n  </script>\n```\n\n![JavaScript classList.add](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20classList.add.gif?alt=media&token=4a64bb15-6c3e-43ab-b839-a9a284b4d53c)\n\n---\n\n## `classList.remove()` 移除 class\n\n使用 `classList.remove()` 方法移除指定的 class：\n\n```html\n  <div id=\"id\" class=\"a1 a2 a3\">請看 class name</div>\n  \n  <script>\n    // classList.remove 移除\n    document.getElementById(\"id\").classList.remove('a1');\n    // classList.remove 移除多筆\n    // document.getElementById(\"id\").classList.add('a2', 'a3', 'a4');\n  </script>\n```\n\n![JavaScript classList.remove](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20classList.remove.gif?alt=media&token=fc3537de-5dc7-4b8a-9521-13aae3ca1477)\n\n---\n\n## `classList.contains()` 判斷 class\n\n使用 `classList.contains()` 方法來判斷元素是否擁有指定的 class：\n\n```html\n  <div id=\"id\" class=\"a1\">請看 class name</div>\n  \n  <script>\n    // classList.contains 判斷是否有對應的 class\n    if (document.getElementById(\"id\").classList.contains('a1')){\n      console.log('Yes');\n    } else {\n      console.log('No');\n    }\n  </script>\n```\n\n![JavaScript classList.contains](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20classList.contains.gif?alt=media&token=2aa60015-3994-4792-8bf1-0a0bc8974159)\n\n---\n\n## `classList.toggle()` 切換 class\n\n`classList.toggle()` 方法可以切換指定的 class：\n\n- **沒有 a2 的時候**：\n\n```html\n  <div id=\"id\" class=\"a1\">請看 class name</div>\n  \n  <script>\n    // classList.toggle 當有對應的 class 就移除，沒有就增加\n    document.getElementById(\"id\").classList.toggle('a2');\n  </script>\n```\n\n![JavaScript classList.toggle example 1](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20classList.toggle%20example%201.gif?alt=media&token=e0f8cb14-49de-444b-a835-23be3e47a732)\n\n- **有 a2 的時候**：\n\n```html\n  <div id=\"id\" class=\"a1 a2\">請看 class name</div>\n  \n  <script>\n    // classList.toggle 當有對應的 class 就移除，沒有就增加\n    document.getElementById(\"id\").classList.toggle('a2');\n  </script>\n```\n\n![JavaScript classList.toggle example 2](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FJavaScript%20classList.toggle%20example%202.gif?alt=media&token=ada873cd-63e4-42fb-88cc-a292be6df11a)\n\n---\n\n## `classList` 函數範例\n\n自定義函數來處理 class 的新增、移除和判斷：\n\n```html\n  <div id=\"id\" class=\"a1 a3\">請看 class name</div>\n  \n  <script>\n    function hasClass(el, className) {\n      if (el.classList) {\n        return el.classList.contains(className);\n      } else {\n        return !!el.className.match(new RegExp('(\\\\s|^)' + className + '(\\\\s|$)'));\n      }\n    }\n          \n    function addClass(el, className) {\n        if (el.classList) {\n          el.classList.add(className);\n        } else if (!hasClass(el, className)) {\n          el.className += \" \" + className;\n        }\n    }\n\n    function removeClass(el, className) {\n        if (el.classList) {\n          el.classList.remove(className);\n        } else if (hasClass(el, className)) {\n          var reg = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n          el.className=el.className.replace(reg, ' ');\n        }\n    }\n    let el = document.getElementById('id')\n    // 新增 a2\n    addClass(el, 'a2')\n    // 移除 a3\n    removeClass(el, 'a3')\n    // 判斷\n    console.log(hasClass(el, 'a1')); // true\n  </script>\n```\n\n![classList 函數範例](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/JavaScript%2FclassList%20function.gif?alt=media&token=8c654a9a-ce76-49f1-9d19-ebe57ed4c725)\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript 基礎篇","url":"/javascript/fundamentals/","content":"\n## 變數 (Variable) 與值 (Value)\n\n- **宣告變數的方法**：`let`、`const`、`var`\n  - 使用 `let` 和 `const` 宣告的變數不會存在於全局 `window` 對象中，使用 `this` 時需要特別注意。\n  [範例](https://codepen.io/nielsen_dch/pen/vYJvYad?editors=1111)\n\n- **基本型別 (Primitive Types)** 介紹：\n  1. 字串 (String)\n  2. 數字 (Number)\n  3. 布林 (Boolean)\n  4. `undefined` - 尚未被賦予值\n  5. `null` - 被賦予值但為空\n  6. `Symbol`\n\n- **型別操作方法**\n\n> 除了基本型別，後面還會講解物件型別，例如陣列 (Array) 與物件 (Object)。\n\n## 比較運算子與邏輯運算子\n\n```javascript\n// 比較運算子：>、=、<=\nlet a = 1;\nlet b = 2;\nlet c = 1;\n\na < b // true\na > b // false\na >= c // true\na <= c // true\n\n// 比較運算子：==、===、!=、!==\n// == 不會進行類型轉換，只需字串內容和數字相同即可為 true\n// === 會先判斷類型，再比較內容，只有型別和內容完全相同才為 true\nlet x = '1';\nlet y = 1;\n\nx == y // true\nx === y // false\nx != y // false\nx !== y // true\n\n// 邏輯運算子：&&、||\n// 使用 && 時，所有判斷條件必須為 true\n// 使用 || 時，只需有一個條件為 true 即可\nlet d = 1;\nlet e = 2;\n\nd === c && e > d // true\nd === c && e < d // false\nd === c || e === d // true\nd === c || e <= d // true\n```\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Hexo NexT _config.yml 設定","url":"/hexo/next-config-configuration/","content":"\n## NexT 主題\n\nNexT 提供了 4 個不同的主題選擇。\n\n```yaml\n# Schemes\n# scheme: Muses\n# scheme: Mist\n# scheme: Pisces\nscheme: Gemini\n```\n\n![NexT 主題示意圖](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20NexT%20Scheme%20Muse%20%26%20Mist.png?alt=media&token=e90008be-4092-4bd7-bd40-c2356079525f)\n\n![NexT 主題示意圖](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20NexT%20Scheme%20Pisces%20%26%20Gemini.png?alt=media&token=74b288e6-cdb6-46aa-8e73-d6a3a1b98541)\n\n## NexT 暗黑模式\n\n```yaml\n# Dark Mode\ndarkmode: true\n```\n\n- **darkmode**: 設定是否開啟暗黑模式，開啟則設定為 `true`。\n\n## favicon 設定\n\n要為您的部落格設置 favicon，請將 favicon 圖片放在 `themes/next/source/images` 目錄下。根據網站風格設計 favicon，並在 `_config.yml` 中配置如下：\n\n```yaml\nfavicon:\n  small: /images/favicon-16x16.png\n  medium: /images/favicon-32x32.png\n  apple_touch_icon: /images/apple-touch-icon.png\n  safari_pinned_tab: /images/logo.svg\n  #android_manifest: /manifest.json\n```\n\n- **small**: 16x16 像素的 favicon 圖片，通常用於瀏覽器標籤。\n- **medium**: 32x32 像素的 favicon 圖片，適用於更大尺寸的顯示需求。\n- **apple_touch_icon**: 用於 iOS 設備的網頁圖標，建議使用 180x180 像素的圖片。\n- **safari_pinned_tab**: 用於 Safari 瀏覽器的固定標籤頁圖標，通常為 32x32 像素的 SVG 圖片。\n- **android_manifest**: 可選，Android 網頁應用程序的 manifest 文件位置，若有使用此功能可配置此選項。\n\n確保 favicon 的設置符合您的網站風格，使您的網站在各種設備上都能夠顯示一致且專業的外觀。\n\n## CC 授權條款\n\n```yaml\n# Creative Commons 4.0 International License.\n# See: https://creativecommons.org/about/cclicenses/\ncreative_commons:\n  # Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | cc-zero\n  license: by-nc-sa\n  # Available values: big | small\n  size: small\n  sidebar: false\n  post: false\n  # You can set a language value if you prefer a translated version of CC license, e.g. deed.zh\n  # CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org\n  language:\n```\n\n- `post` 設置為 `true` 會在文章底部顯示 CC 授權條款。\n- `sidebar` 設置為 `true` 會在側邊欄顯示 CC 授權條款。\n\n## 選單設定\n\n```yaml\nmenu:\n  home: / || fa fa-home\n  about: /about/ || fa fa-user\n  tags: /tags/ || fa fa-tags\n  categories: /categories/ || fa fa-th\n  archives: /archives/ || fa fa-archive\n  #schedule: /schedule/ || fa fa-calendar\n  #sitemap: /sitemap.xml || fa fa-sitemap\n  #commonweal: /404/ || fa fa-heartbeat\n```\n\n![選單設定示意圖](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20NexT%20Sidebar.png?alt=media&token=c4b5566b-e0ae-430b-b307-af943eeaafa5)\n\n## 側邊選單位置\n\n預設為 `left`，依照個人喜好修改顯示位置\n\n```yaml\nsidebar:\n  # Sidebar position. Available values: left | right\n  position: right\n```\n\n## 頭像\n\n```yaml\n# Sidebar Avatar\navatar:\n  # Replace the default image and set the URL here.\n  url: /images/avatar.gif\n  # 如果為 true，頭像外框為圓形\n  rounded: false\n  # 如果為 true，頭像將隨著游標旋轉\n  rotated: false\n```\n\n![頭像設定示意圖](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FAvatar%20illustration.png?alt=media&token=45552242-bc7c-4c38-ae8c-1ace5a10a22a)\n\n## 社交平台設定\n\n```yaml\nsocial:\n  GitHub: https://github.com/asz8621 || fab fa-github\n  E-Mail: mailto:asz718460@gmail.com || fa fa-envelope\n  #Weibo: https://weibo.com/yourname || fab fa-weibo\n  #Twitter: https://twitter.com/yourname || fab fa-twitter\n  #FB Page: https://www.facebook.com/yourname || fab fa-facebook\n  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow\n  #YouTube: https://youtube.com/yourname || fab fa-youtube\n  #Instagram: https://instagram.com/yourname || fab fa-instagram\n  #Skype: skype:yourname?call|chat || fab fa-skype\n```\n\n![社交平台設定示意圖](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20NexT%20Social.png?alt=media&token=d5900492-e8bc-420e-9b41-7b04f9b25254)\n\n## footer 設定\n\n![footer 設定示意圖](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20NexT%20Footer.png?alt=media&token=91e0ce30-8a0a-42bb-b61f-a48d75c3eb32)\n\n```yaml\nfooter:\n  # Specify the year when the site was setup. If not defined, current year will be used.\n  #since: 2021\n\n  # Icon between year and copyright info.\n  icon: # [黃色方框]\n    # Icon name in Font Awesome. See: https://fontawesome.com/icons\n    name: fa fa-heart\n    # If you want to animate the icon, set it to true.\n    animated: true\n    # Change the color of the icon, using Hex Code.\n    color: \"#ff0000\"\n\n  # If not defined, `author` from Hexo `_config.yml` will be used.\n  # Set to `false` to disable the copyright statement.\n  copyright: 'Nielsen' # [綠色方框]\n\n  # Powered by Hexo & NexT\n  powered: true # [紫色方框]\n\n  # Beian ICP and gongan information for Chinese users. See: https://beian.miit.gov.cn, https://beian.mps.gov.cn\n  beian:\n    enable: false\n    icp:\n    gongan_id:\n    gongan_num:\n    gongan_icon_url:\n```\n\n![footer 設定示意圖動畫](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20NexT%20Footer%20animated.gif?alt=media&token=b7f74014-a070-4648-a834-810a017215dc)\n\n## 文章元數據顯示設置\n\n這段配置允許你自訂文章頁面的元數據顯示選項。\n\n![文章元數據示意圖](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20NexT%20Post%20meta.png?alt=media&token=7e6bc236-7121-438d-beb2-1a064b539bd6)\n\n```yaml\n# Post meta display settings\npost_meta:\n  item_text: true      # 顯示項目文本\n  created_at: true     # 顯示創建日期\n  updated_at:\n    enable: true      # 隱藏最後更新日期\n    another_day: true # 顯示與創建日期不同的日期\n  categories: true     # 顯示分類\n```\n\n- `item_text: true`：顯示項目文本。\n- `created_at: true`：顯示文章的創建日期。\n- `updated_at`：\n  - `enable: true`：顯示最後更新日期。\n  - `another_day: true`：若啟用，會顯示與創建日期不同的日期（需配合 `enable: true` 使用）。\n- `categories: true`：顯示文章的分類。\n\n## 修改程式碼顯示樣式\n\n```yaml\ncodeblock:\n  # Code Highlight theme\n  # All available themes: https://theme-next.js.org/highlight/\n  theme:\n    light: default\n    dark: stackoverflow-dark\n  prism:\n    light: prism\n    dark: prism-dark\n  # Add copy button on codeblock\n  copy_button:\n    enable: false\n    # Available values: default | flat | mac\n    style:\n  # Fold code block\n  fold:\n    enable: false\n    height: 500\n```\n\n### 高量設定\n\n可以參考以下設置。可用的主題列表在這裡：[Code Highlight Themes](https://theme-next.js.org/highlight/)\n\n```yaml\n  theme:\n    light: default\n    dark: stackoverflow-dark\n```\n\n![code theme](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20NexT%20code%20theme.png?alt=media&token=9ef59dbc-4f49-46a8-bc5b-60a3a9f2caad)\n\n### 複製按鈕設定\n\n要啟用複製按鈕，請將 `enable` 設為 `true`，此時 `style` 設定才會生效。\n\n```yaml\n  copy_button:\n    enable: false\n    # Available values: default | flat | mac\n    style: mac\n```\n\n![code copy button](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20NexT%20code%20copy%20button.png?alt=media&token=8f273400-8092-47ea-bcd6-ab4c27bd31c2)\n\n### 代碼摺疊\n\n```yaml\n  fold:\n    enable: true\n    height: 100\n```\n\n![code fold](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20NexT%20code%20fold.png?alt=media&token=1047bf43-7bc2-4fce-93a0-27d932ce697d)\n\n## 返回頂部\n\n```yaml\nback2top:\n  enable: true\n  # Back to top in sidebar.\n  sidebar: false\n  # Scroll percent label in b2t button.\n  scrollpercent: false\n```\n\n- 將 `sidebar` 設定為 `true` 可以在側邊欄的個人資訊區塊中顯示回到頂部按鈕。\n\n![至頂按鈕示意圖](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20NexT%20Sidebar%20back2top.png?alt=media&token=7a2d017e-57cb-46f9-9915-4e9c3fa99289)\n\n- 將 `scrollpercent` 設定為 `true` 會顯示閱讀進度百分比。\n\n## 閱讀進度條\n\n```yaml\n# Reading progress bar\nreading_progress:\n  enable: false\n  # Available values: left | right\n  start_at: left\n  # Available values: top | bottom\n  position: top\n  reversed: false\n  color: \"#37c6c0\"\n  height: 3px\n```\n\n- `enable`: 設定是否開啟進度條，開啟則設定為 `true`。\n- `start_at`: 設定進度條開始位置，選擇 `left` 或 `right`。\n- `position`: 設定進度條在頂部或底部顯示。\n- `reversed`: 是否反轉進度條。\n- `color`: 設定進度條顏色。\n- `height`: 設定進度條高度。\n\n## GitHub 右上角 ICON\n\n```yaml\n# `Follow me on GitHub` banner in the top-right corner.\ngithub_banner:\n  enable: true\n  permalink: https://github.com/yourname\n```\n\n![GitHub 右上角 ICON 示意圖](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FGitHub%20top-right%20Icon.png?alt=media&token=8c5ecf28-f310-4107-bec9-84877dc7c05b)\n\n## Note 設定\n\n```yaml\nnote:\n  # Note tag style values:\n  #  - simple    bootstrap callout old alert style. Default.\n  #  - modern    bootstrap callout new (v2-v3) alert style.\n  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.\n  #  - disabled  disable all CSS styles import of note tag.\n  style: simple\n  icons: false\n  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).\n  # Offset also applied to label tag variables. This option can work with disabled note tag.\n  light_bg_offset: 0\n```\n\n以下是 Note 標籤的樣式：\n\n{% tabs Note style, 1 %}\n<!-- tab simple -->\n![Note style simple](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2Fnote%20style%20simple.png?alt=media&token=841dc1c0-694d-40f8-a439-7afa50fbe1ff)\n<!-- endtab -->\n<!-- tab modern -->\n![Note style modern](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2Fnote%20style%20modern.png?alt=media&token=1316553f-9a85-4589-be4d-b3a784fdebc1)\n<!-- endtab -->\n<!-- tab flat -->\n![Note style flat](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2Fnote%20style%20flat.png?alt=media&token=45351969-5edb-4009-badc-7d44668ca665)\n<!-- endtab -->\n{% endtabs %}\n\n`icons` 的顯示可以根據個人喜好選擇是否啟用。\n\n如果您不喜歡樣式中的背景色，可以調整 `light_bg_offset` 來改變背景色的亮度。\n\n## Tabs 設定\n\n```yaml\ntabs:\n  # Make the nav bar of tabs with long content stick to the top.\n  sticky: false\n  transition:\n    tabs: false\n    labels: true\n```\n\n- `sticky`: 設置導航欄是否在滾動時固定在頁面頂部。設置為 `false` 表示導航欄不會固定。\n- `transition`: 控制標籤頁和標籤的過渡效果。將 `tabs` 和 `labels` 設置為 `true` 以啟用平滑過渡。\n\n## 載入進度條設定\n\n1. 編輯 `theme/_config.yml` 文件，啟用並配置進度條：\n\n    ```yaml\n    # 詳細資訊: https://github.com/CodeByZach/pace\n    pace:\n      enable: true\n      # 可選顏色:\n      # black | blue | green | orange | pink | purple | red | silver | white | yellow\n      color: blue\n      # 可選主題:\n      # 詳細資訊: https://codebyzach.github.io/pace/#get-started-snippet\n      # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple\n      # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal\n      theme: minimal\n    ```\n\n![進度條設定示意圖](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FProgress%20bar%20illustration.png?alt=media&token=befa9a8e-7a63-4efa-8bbf-065b9f543193)\n\n## 搜尋欄位設定\n\n1. 安裝搜尋插件：\n\n    ```yaml\n    npm install hexo-generator-search --save\n    ```\n\n2. 編輯根目錄下的 `_config.yml` 文件，加入搜尋欄位設定：\n\n    ```yaml\n    # Extensions\n    ## Plugins: https://hexo.io/plugins/\n    ## Themes: https://hexo.io/themes/\n    theme: next\n\n    ## 加入搜尋欄位\n    search:\n      path: search.json\n      field: post\n    ```\n\n3. 編輯 `theme/next/_config.yml` 文件以啟用本地搜尋\n\n   將 `local_search` 的 `enable` 設為 `true`，並根據需要調整其他設定：\n\n   ```yaml\n   # Local Search\n   # Dependencies: https://github.com/next-theme/hexo-generator-searchdb\n   local_search:\n     enable: true\n     # 每篇文章顯示的搜尋結果數量，設為 -1 以顯示所有結果\n     top_n_per_article: 1\n     # 是否取消 HTML 字符串的轉義為可讀文本\n     unescape: false\n     # 頁面加載時是否預加載搜尋數據\n     preload: false\n   ```\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"Hexo _config.yml 設定","url":"/hexo/config-configuration/","content":"\nHexo 的 `_config.yml` 文件包含了網站的基本配置設定，可以迅速上手並優化 Hexo，以下我就介紹我有改過的參數。\n\n## 網站設定\n\n這部分設定影響網站的 SEO 分數。建議完整填寫以提升搜尋引擎排名。\n\n```yaml\n# Site\ntitle: Hexo\nsubtitle: ''\ndescription: ''\nkeywords:\nauthor: John Doe\nlanguage: en\ntimezone: ''\n```\n\n- **title**: 設定您的網站標題。例如：`我的部落格`。\n- **subtitle**: 設定網站副標題（可選）。例如：`分享我的思考`。\n- **description**: 設定網站簡短描述，幫助搜尋引擎和訪客了解網站內容。例如：`一個關於科技和編程的部落格`。\n- **keywords**: 設定與網站內容相關的關鍵字，以便於 SEO。例：`科技, 編程, 教程`。\n- **author**: 設定網站作者名字。例如：`Nielsen`。\n- **language**: 設定網站語言。`en` 表示英語，`zh-TW` 表示繁體中文等。\n- **timezone**: 設定網站時區。可留空或使用適合的時區標識，例如 `Asia/Taipei`。\n\n## 網址設定\n\n```yaml\n# URL\n## Set your site url here. For example, if you use GitHub Pages, set url as 'https://username.github.io/project'\nurl: http://example.com\npermalink: :year/:month/:day/:title/\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n```\n\n- **url**: 設定網站的根地址。例如：`https://asz8621.github.io`。\n- **permalink**: 設定文章 URL 的結構。例如：`:year:month:day/:title/` -> 20240910/我的文章。\n- **permalink_defaults**: 設定永久鏈接的默認值（如有需要）。\n- **pretty_urls**: 配置 URL 是否包含 `index.html` 和 `.html` 擴展名。\n\n您可以自定義 `permalink` 參數來管理文章的 URL。如果選擇自訂參數（如 `:url/`），每篇文章都需要包含 `url` 參數，否則文章可能無法正確顯示。\n\n![文章 Front-Matter](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20Front-Matter.png?alt=media&token=b3567697-9059-4e45-bd6c-7688895c9a1e)\n\n## 分類與標籤\n\n```yaml\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n```\n\n- **default_category**: 設定預設分類，用於未指定分類的文章。\n- **category_map**: 設定分類名稱，幫助統一顯示和管理分類。\n- **tag_map**: 設定標籤名稱，幫助統一顯示和管理標籤。\n\ndefault_category 預設就好\ncategory_map 和 tag_map 如果有英文大小寫的分類與標籤建議設定\n假設我有一個分類與標籤都是 Vue ，這樣網址會是 `網域/categories/Vue` 與 `網域/tags/Vue/`\n\n如果跟我一樣希望網址都是小寫可以這樣設定\n\n```yaml\ndefault_category: uncategorized\ncategory_map:\n  Vue: vue\ntag_map:\n  Vue: vue\n```\n\n這樣網址就會是 `網域/categories/vue` 與 `網域/tags/vue/`\n\n## 主題\n\n```yaml\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next\n```\n\n在之前的文章我就已經把主題改成 NexT\n\n## 部屬方式\n\n```yaml\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: ''\n```\n\n如果要部屬到 GitHub 再參考 [將 Hexo 上傳到 GitHub](/hexo/upload-hexo-to-github/)\n\n大致上改這些參數就可以了，今天就先到這裡，其他參數的部份等我有遇到在做補充\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"將 Hexo 上傳到 GitHub","url":"/hexo/upload-hexo-to-github/","content":"\n## 前往 GitHub 註冊帳號\n\n   訪問 [GitHub](https://github.com/) 並註冊帳號。\n\n## 建立專案\n\n   登入後，點擊右上角的 `+`，選擇 `New repository` 來創建新的專案。\n\n   ![GitHub 專案創建步驟](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FCreate%20new%20repository%20on%20GitHub.png?alt=media&token=cafdc694-9472-4f3b-8f6f-d0e548d5433a)\n\n## 填寫專案名稱\n\n   輸入專案名稱，並確保它符合 GitHub Pages 的要求，例如 `<username>.github.io`。\n\n   ![GitHub 專案名稱填寫](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FRepository%20name%20on%20GitHub.png?alt=media&token=9731430c-9d9d-4390-b482-fcad77f053d9)\n\n## 等待創建 GitHub 專案\n\n   看到以下畫面就代表正在等待你上傳專案。\n\n   ![GitHub 等待上傳專案](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FEmpty%20GitHub%20repository.png?alt=media&token=476800e5-814f-4df9-8397-05eef756e0e5)\n\n## 安裝 Hexo 部署 Git 插件\n\n   使用以下命令安裝 Hexo 的 Git 部署插件：\n\n   ```bash\n   npm install hexo-deployer-git --save\n   ```\n\n## 配置部署設定\n\n參考網站 [Hexo GitHub Pages 部署](https://hexo.io/zh-tw/docs/github-pages#One-command-deployment)。\n\n在 Hexo 根目錄的 `_config.yml` 文件中，添加或更新以下部署設定：\n\n```yaml\ndeploy:\n   type: git\n   repo: https://github.com/<username>/<project>\n   # 示例: https://github.com/username/username.github.io\n   branch: gh-pages\n```\n\n- **repo**: 設定 GitHub 專案的 URL，例如 `https://github.com/username/username.github.io`。\n- **branch**: 通常設為 `gh-pages`，這是 GitHub Pages 的默認分支。\n\n## 清理並部署\n\n   執行以下命令來清理舊的生成文件並部署您的 Hexo 部落格：\n\n   ```bash\n   hexo clean\n   hexo deploy\n   ```\n\n   `hexo clean` 用於清除舊的生成文件，`hexo deploy` 則將網站部署到 GitHub Pages 上。\n","tags":["Hexo","GitHub"],"categories":["Hexo"]},{"title":"Hexo NexT 主題安裝","url":"/hexo/next-install/","content":"\n## Hexo NexT 主題安裝指南\n\n在這篇文章中，我們將介紹如何安裝 Hexo 的 NexT 主題。NexT 主題因其簡潔而優雅的外觀而受到廣泛使用。若您有興趣探索其他主題，可以參考 [Hexo 主題市場](https://hexo.io/themes/)。以下步驟將引導您完成 NexT 主題的安裝和配置。\n\n## 實作步驟\n\n### 1. 初始化 Hexo\n\n首先，進入您的網站資料夾並初始化 Hexo：\n\n```bash\ncd <你的網站資料夾>\nhexo init\nhexo server\n```\n\n啟動本地伺服器後，您應該會看到以下畫面：\n![開啟部落格畫面](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20completion%20screen.png?alt=media&token=674d8217-91ae-491a-898a-f6b6dfebb5a0)\n\n### 2. 安裝 NexT 主題\n\n在 `themes` 資料夾中安裝 NexT 主題：\n\n```bash\ngit clone https://github.com/next-theme/hexo-theme-next themes/next\n```\n\n安裝過程的畫面如下：\n![安裝 NexT 主題畫面](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FInstall%20Hexo%20theme.png?alt=media&token=f13b8c8a-d799-4246-81c9-539dc6e04bb7)\n\n### 3. 修改主題設定\n\n打開 Hexo 配置文件 `_config.yml`，將主題設定為 `next`：\n\n![修改主題畫面](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FConfigure%20Hexo%20theme.png?alt=media&token=8f51b3ad-fe79-49cb-9b18-af5a5d0f06a5)\n\n### 4. 確認主題是否已套用\n\n重新啟動 Hexo 伺服器來確認主題是否成功應用：\n\n```bash\nhexo server\n```\n\n如果遇到以下錯誤畫面：\n\n![Hexo plugin is not installed](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20theme%20error-1.png?alt=media&token=f9e3fa83-1294-425a-8196-7e25b3cf8378)\n![hexo server highlight error](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20theme%20error-2.png?alt=media&token=31c5e4d3-80df-487d-b051-f10ade00bb84)\n\n您可以嘗試以下步驟來解決問題：\n\n對於 Windows 用戶，使用以下指令刪除 `node_modules` 資料夾（注意，這與其他作業系統的指令略有不同）：\n\n```bash\nRemove-Item -Recurse -Force -Path .\\node_modules\nnpm install\n```\n\n或者，您可以安裝缺少的套件：\n\n```bash\nnpm install css --save\nnpm install hexo-util --save\nnpm install js-yaml --save\nnpm install highlight.js --save\n```\n\n### 5. 完成設置\n\n完成所有步驟後，您應該會看到成功設置的部落格畫面：\n\n![完成部落格畫面](https://firebasestorage.googleapis.com/v0/b/blog-bc88e.appspot.com/o/Hexo%2FHexo%20Next%20theme%20installation%20completed.png?alt=media&token=f23dbdd0-8ee8-4e26-8291-09811bb00fb5)\n\n恭喜您！您的 Hexo 部落格已成功建立並配置完成。\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"Hexo 部落格建立指南","url":"/hexo/blog-setup-guide/","content":"\n## 前言\n\nHexo 是一個快速、簡單且高效的靜態網站生成器，非常適合用來建立個人部落格。本文將指導您從安裝 Hexo 到配置主題的每一步，讓您能夠快速開始使用 Hexo 來記錄生活和工作。\n\n## 環境安裝\n\n### 安裝必要工具\n\n在開始之前，您需要安裝以下工具：\n\n- [Node.js](https://nodejs.org/en)（版本 14 或更高）\n- [Git](https://git-scm.com/)\n\n下載並安裝這些工具後，請確認它們的版本：\n\n```bash\nnode -v\nnpm -v\ngit -v\n```\n\n### 安裝 Hexo CLI\n\n使用 npm 安裝 Hexo CLI 工具：\n\n```bash\nnpm install -g hexo-cli\n```\n\n確認 Hexo CLI 是否安裝成功：\n\n```bash\nhexo -v\n```\n\n## 常用 Hexo 指令\n\n以下是一些常用的 Hexo 指令：\n\n- **初始化部落格**\n\n  ```bash\n  hexo init <你的網站名稱>\n  ```\n\n- **啟動本地伺服器**\n\n  ```bash\n  hexo server\n  ```\n\n- **新增一篇文章**\n\n  ```bash\n  hexo new \"部落格標題\"\n  ```\n\n- **生成靜態文件**\n\n  ```bash\n  hexo generate\n  ```\n\n- **清除快取**\n\n  ```bash\n  hexo clean\n  ```\n\n- **部署網站**\n\n  ```bash\n  hexo deploy\n  ```\n\n## 配置文件介紹\n\nHexo 的主要配置文件為 `_config.yml`。詳細設定說明可參見 [Hexo 官方文檔](https://hexo.io/zh-tw/docs/configuration)。\n\n## 主題（Theme）\n\n選擇合適的主題可以提升部落格的外觀和使用體驗。以下是兩個流行的 Hexo 主題及其安裝方法：\n\n### 1. Landscape 主題（預設）\n\n- 主題網址：[Hexo Theme Landscape](https://github.com/hexojs/hexo-theme-landscape)\n- 安裝指令：\n\n  ```bash\n  git clone --depth 1 https://github.com/hexojs/hexo-theme-landscape themes/landscape\n  ```\n\n- 配置設定（`_config.yml`）：\n\n  ```yaml\n  theme: landscape\n  ```\n\n### 2. NexT 主題\n\n- 主題網址：[Hexo Theme Next](https://github.com/next-theme/hexo-theme-next)\n- 安裝指令：\n\n  ```bash\n  git clone https://github.com/next-theme/hexo-theme-next themes/next\n  ```\n\n- 配置設定（`_config.yml`）：\n\n  ```yaml\n  theme: next\n  ```\n\n其他主題請參考 [Hexo 主題市場](https://hexo.io/themes/)。\n\n在下一篇文章中，我們將說明如何更改部落格主題，敬請期待！\n","tags":["Hexo"],"categories":["Hexo"]}]